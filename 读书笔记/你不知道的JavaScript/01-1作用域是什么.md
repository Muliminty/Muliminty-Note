
## 1.1编译原理
### 分词/词法分析（Tokenizing/Lexing）

将字符组成的字符串分解成（对编程语言来说）有意义的代码块，这些代码块被称为词法单元（token）​。

```js
var a = 2;
//分解成为下面这些词法单元：
//var、a、=、2 、;
```

分词（tokenizing）和词法分析（Lexing）之间的区别是非常微妙、晦涩的，主要差异在于词法单元的识别是通过**有状态还是无状态**的方式进行的。

简单来说，如果词法单元生成器在判断a是一个独立的词法单元还是其他词法单元的一部分时，调用的是有状态的解析规则，那么这个过程就被称为词法分析。

> 简言之，词法分析器比分词器更复杂，它不仅仅把字符流切割成词法单元，还会根据上下文来识别这些单元的类型和含义，这就是“有状态”的部分。
[20250221182630](备注/20250221182630.md)


### 解析/语法分析（Parsing）

这个过程是将词法单元流（数组）转换成一个由元素逐级嵌套所组成的代表了程序语法结构的树。这个树被称为“[抽象语法树-AST](../../小记/抽象语法树：Abstract%20Syntax%20Tree,AST.md)”​（Abstract Syntax Tree,AST）​。


var a = 2；的抽象语法树中可能会有一个叫作VariableDeclaration的顶级节点，接下来是一个叫作Identifier（它的值是a）的子节点，以及一个叫作AssignmentExpression的子节点。AssignmentExpression节点有一个叫作NumericLiteral（它的值是2）的子节点。

对于 JavaScript 代码 `var a = 2;`，其抽象语法树可以表示为以下结构：

```json
{
  "type": "Program",
  "body": [
    {
      "type": "VariableDeclaration",
      "declarations": [
        {
          "type": "VariableDeclarator",
          "id": {
            "type": "Identifier",
            "name": "a"
          },
          "init": {
            "type": "Literal",
            "value": 2,
            "raw": "2"
          }
        }
      ],
      "kind": "var"
    }
  ],
  "sourceType": "script"
}
```

解释：
1. **Program**: 表示整个程序，`body` 属性包含程序中的所有语句。
2. **VariableDeclaration**: 表示变量声明语句，`kind` 属性表示声明的类型（这里是 `var`）。
3. **VariableDeclarator**: 表示变量声明中的声明符，`id` 是变量名，`init` 是变量的初始值。
4. **Identifier**: 表示变量名，`name` 属性是变量的名称（这里是 `a`）。
5. **Literal**: 表示字面量，`value` 是字面量的值（这里是 `2`），`raw` 是原始的字符串表示。

可视化结构：
```
Program
└── body: [
    └── VariableDeclaration
        ├── kind: "var"
        └── declarations: [
            └── VariableDeclarator
                ├── id: Identifier
                │   └── name: "a"
                └── init: Literal
                    ├── value: 2
                    └── raw: "2"
        ]
    ]
```

这个 AST 结构描述了代码 `var a = 2;` 的语法结构。


### 代码生成

将AST转换为可执行代码的过程被称为代码生成。

简单来说就是有某种方法可以将var a =2；的AST转化为一组机器指令，用来创建一个叫作a的变量（包括分配内存等）​，并将一个值储存在a中

在语法分析和代码生成阶段有特定的步骤来对运行性能进行优化，包括对冗余元素进行优化等。

javaScript的编译过程不是发生在构建之前的。

在我们所要讨论的作用域背后，JavaScript引擎用尽了各种办法（比如[JIT](../../00-编程/前端基础-JavaScript/02-进阶机制/深入-知识点/编译原理/编译原理-即时编译JIT.md)，可以延迟编译甚至实施重编译）来保证性能最佳。


简单地说，任何JavaScript代码片段在执行前都要进行编译（通常就在执行前）​。因此，JavaScript编译器首先会对var a = 2；这段程序进行编译，然后做好执行它的准备，并且通常马上就会执行它。


### 总结

1. **分词/词法分析（Tokenizing/Lexing）**  
   将代码字符串分解为有意义的词法单元（tokens）。  
   例如：`var a = 2;` → `var`、`a`、`=`、`2`、`;`  
   - **分词**：无状态切割字符流。  
   - **词法分析**：有状态识别词法单元的类型和含义。

2. **解析/语法分析（Parsing）**  
   将词法单元流转换为**抽象语法树（AST）**，表示代码的语法结构。  
   例如：`var a = 2;` 的 AST：

3. **代码生成**  
   将 AST 转换为可执行代码（如机器指令）。  
   - 例如：为 `var a = 2;` 分配内存并存储值。  
   - **优化**：在语法分析和代码生成阶段进行性能优化（如 JIT 编译）。

4. **JavaScript 编译特点**  
   - 编译通常发生在代码执行前（即时编译）。  
   - JavaScript 引擎通过 JIT 等技术优化性能。  
   - 任何代码片段在执行前都会被编译。  

核心要点
- **分词**：将代码字符串拆分为词法单元。  
- **解析**：将词法单元转换为 AST，描述代码结构。  
- **代码生成**：将 AST 转换为可执行代码。  
- **即时编译**：JavaScript 代码在执行前被编译，引擎通过优化技术保证性能。

## 1.2 理解作用域

编译需要的工具

**引擎**

从头到尾负责整个JavaScript程序的编译及执行过程。

**编译器**

负责语法分析及代码生成等脏活累活

**作用域**

负责收集并维护由所有声明的标识符（变量）组成的一系列查询，并实施一套非常严格的规则，确定当前执行的代码对这些标识符的访问权限。

---

```
var a = 2； 
的编译流程
```

编译器首先会将这段程序分解成词法单元

将词法单元解析成一个树结构

编译器会进行如下处理。

```
遇到var a，编译器会询问作用域是否已经有一个该名称的变量存在于同一个作用域的集合中。如果是，编译器会忽略该声明，继续进行编译；否则它会要求作用域在当前作用域的集合中声明一个新的变量，并命名为a。
```

