# Redux

> 内容整理至 [哔哩哔哩 -- redux全局状态管理学习路线之一 : redux&react-redux](https://www.bilibili.com/video/BV1oE411V7RW/?spm_id_from=333.337.search-card.all.click&vd_source=55188e441990ee2ff1e28fae2d46edc2)

## 1. Redux 概述

### 1.1什么是Redux

![img](https://img2023.cnblogs.com/blog/2230292/202303/2230292-20230308110700769-751347922.png)

接下来我们就要去学习一下我们的Redux， Redux 它到底是干嘛用的？在我们的一个 react 中，如果我们想要去做全局化的状态管理，我们必然就要去学习到我们一个Redux。如果有些小伙伴对 Vue 有过接触的，应该会知道，在 Vue 的生态中，是不是也有一个来做全局状态管理的名字，叫做我们的Vuwx。在 react 中，我们要去实现这一个点，就要借助于我们的Redux。今天我们会围绕三个部分去介绍我们的Redux。

第一个是 Redux 概述，第二个是 Redux 组成部分，第三个就是去使用我们的 Redux 来做一个入门级别的小案例。好，我们就进入到第一个点的学习。

我们先了解一下什么是Redux：

**Redux 是用于加 Scrap 的状态容器，提供可预测化的一个状态管理。**

其实说白了， Reduc 是一个容器，就是用来存储数据的。

**Reduc，可以让你构建一致化的应用于不同的环境，例如客户端、服务器、原生应用，并且易于测试。**

**而我们的 Reduc 除了和 react 一起使用外，它还支持一些其他的界面库，而且它的体积特别的小，只有 2 k p，这样就不会对你们今后打包项目造成困扰。**

### 1.2Redux的设计初衷

![img](https://img2023.cnblogs.com/blog/2230292/202303/2230292-20230308110604433-114155059.png)

再来看一点就是 Redux 的设计初衷了，随着我们加 Scrap 单页面开发日期复杂，加 Scrap 需要管理更多的state，也就是我们的状态，也就是我们所说的数据，而这些 state 可能包括服务器的响应、缓存数据、本地生成未持久化到服务器的数据等等，也包含了我们的 UI 的状态。所以也就意味着我们要需要更多的逻辑去处理这些的数据。管理不断变化的 state 是非常麻烦的。

大家来设想一下，如果我们有一个数据model，这个数据模型 model 的变化，它会引起另外一个 model 的变化。也就当我们的 view 变化的时候，就可能会引起我们的 model 以及另一个 model 变化，依次可能会引起另一个 view 的变化，所以产生了混乱。而我们的 reduce 就是为了去解决掉这样的一个问题的。

### 1.2Redux的三大核心

Redux有三大核心，我们来看一下。

**第一个是单一数据源。**

![img](https://img2023.cnblogs.com/blog/2230292/202303/2230292-20230308111130665-996645969.png)

什么是单一数据源？就是整个应用的 state 会被存储在一颗叫做 object tree 中，而 object train 只存在于唯一的一个 store 中。大家来看下面这张图。在我们一个应用里面，我们可能会存在于很多个state，不同的组件都会维护自己的 state 对吧？而这些 state 相互之间如果有冲突或者有联系，一个变了可能就会引起另外一个变化。而在 Redux 三大核心中的第一个就是单一数据源。任何的一个 state 都会被存储在我们的一个 object 群中，而 object 群实际上你就可以把它理解成为什么我们的一个对象，就像我们的一个 DOM 对象一样，放在我们的一个内存当中的，用它来对我们整个应用的一个 state 来进行一个管理。

**第二个核心点是 state 是只读的。**

![img](https://img2023.cnblogs.com/blog/2230292/202303/2230292-20230308120930018-1956549437.png)

什么是只读的？其实并不是我们的 state 只能读不能修改的意思。这里的意思指的是唯一改变 state 的方法，就是要触发一个action， action 就是用于描述已发生事情的一个普通对象。听到这里，我们应该知道，如果我们想要去修改 state 状态，那意味着我要触发一个action。 action 又是个什么东西？它就是一个普通的对象，这样能够确保我们的视图和网络请求都不会直接去修改state。相反，他们只能表达要想修改的意图，因为所有的修改都会被集中化处理，并且严格按照一个接一个的顺序去执行。这就是我们的一个action。

如果我们想要去发一个action，其实很简单，我们如果有了我们的 store 全局对象，我们只需要调用它的方法就可以去发送一个 action 了。这是简单的一个什么示例，大家先有个印象，后面我们会在代码中去进行体现。

**第三大核心点就是使用纯函数来执行我们的修改。**

![img](https://img2023.cnblogs.com/blog/2230292/202303/2230292-20230308121304599-211221424.png)

为了描述我们 action 如何去改变我们 state tree，也就是我们状态树，你必须要去编写一个reducers。 reducers 又是个什么东西？先带着这个疑问。其实我们的 reducers 就是一些纯函数，就是一些纯函数。但是他会去接收先前的 state 和我们的一个action。好吧，他会去接收先前的 state 和我们的一个action，并且它会返回一个新的state。纯函数的好处可以复用，对吧？纯函数的好处可以复用。我们这样去做，既可以去控制我们的顺序，又可以干嘛去传入我们的一个符合参数。

### 小结

![img](https://img2023.cnblogs.com/blog/2230292/202303/2230292-20230308121601888-434808301.png)

好，这是我们的三大核心。我们先来小结一下，在 Redux 代数里面，我们讲了一些相应的知识点。第一个我们讲到了 Redux 其实就是一个javascript容器，而且它就是用于进行全局化的一个状态管理的。第二个点是什么？我们讲解到了 Redux 三大核心。第一大核心是单一数据源对吧？我们所有的 state 都会被挂载到一个叫做 object train 中，而我们 object train 和我们的一个 store 是存在一一对应的。

第二个，我们讲解到了 state 是只读的，只读的，如果我们想要去修改到state，那就意味着我们要去发送一个action。第三个，使用纯函数来执行修改，纯函数就能保证我们的复用性。其实我们的 reducers 就是一个纯函数，为了去接收我们的一个 action 的，并且我们可以根据返回值去处理我们要返回的新的state。

好，在这里我们讲解。其实讲解出来了一个专业的术语，对吧？有一个什么action，有一个reducer，还有一个store。可能听到这里诶，小伙伴们还在有点疑惑这是啥呢？这些是啥东西呢？而刚开始的我们讲解的 3 大核心里面，对于 action 我们有个初步的认识，它好像是用来描述要触发某些意图的。

而我们的 reducers 在里面也有一个相应的介绍。 reducers 其实就是一些纯函数，用来接收谁，用来接收我们的 action 的，并且根据它返回的值可以去返回一个新的state，对吧？好，但是现在我们可能还没法关联起来这几个东西，它们之间到底有什么样的联系诶？不用急，我们下一个知识点结果去讲解。到好，这个点，我们就先讲到这里。
