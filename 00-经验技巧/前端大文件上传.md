# å‰ç«¯å¤§æ–‡ä»¶ä¸Šä¼ ï¼ˆLarge File Uploadï¼‰å®Œæ•´è§£å†³æ–¹æ¡ˆ

> å‰ç«¯å¤§æ–‡ä»¶ä¸Šä¼ çš„å®ç°æ–¹æ¡ˆï¼ŒåŒ…æ‹¬åˆ†ç‰‡ä¸Šä¼ ã€æ–­ç‚¹ç»­ä¼ ã€è¿›åº¦ç›‘æ§ã€é”™è¯¯å¤„ç†ç­‰å®Œæ•´åŠŸèƒ½ã€‚
> 
> **æ¶‰åŠæŠ€æœ¯**ï¼šFile APIã€Blob APIã€FileReader APIã€FormData APIã€XMLHttpRequestã€Fetch API
> 
> **å‚è€ƒæ–‡æ¡£**ï¼š
> - [File API](../00-å‰ç«¯ä½“ç³»/01-åŸºç¡€å…¥é—¨/JavaScript/08-æµè§ˆå™¨ç¯å¢ƒä¸DOM/File-API.md) â€” æ–‡ä»¶å¯¹è±¡æ“ä½œ
> - [Blob API](../00-å‰ç«¯ä½“ç³»/01-åŸºç¡€å…¥é—¨/JavaScript/08-æµè§ˆå™¨ç¯å¢ƒä¸DOM/Blob-API.md) â€” äºŒè¿›åˆ¶å¤§å¯¹è±¡
> - [FileReader API](../00-å‰ç«¯ä½“ç³»/01-åŸºç¡€å…¥é—¨/JavaScript/08-æµè§ˆå™¨ç¯å¢ƒä¸DOM/FileReader-API.md) â€” æ–‡ä»¶è¯»å–
> - [FormData API](../00-å‰ç«¯ä½“ç³»/01-åŸºç¡€å…¥é—¨/JavaScript/08-æµè§ˆå™¨ç¯å¢ƒä¸DOM/FormData-API.md) â€” è¡¨å•æ•°æ®å’Œæ–‡ä»¶ä¸Šä¼ 

---

## ğŸ“š ç›®å½•

- [1. é—®é¢˜åˆ†æ](#1-é—®é¢˜åˆ†æ)
- [2. æŠ€æœ¯æ–¹æ¡ˆ](#2-æŠ€æœ¯æ–¹æ¡ˆ)
- [3. æ ¸å¿ƒå®ç°](#3-æ ¸å¿ƒå®ç°)
- [4. å®Œæ•´ Demo](#4-å®Œæ•´-demo)
- [5. è¿›é˜¶ä¼˜åŒ–](#5-è¿›é˜¶ä¼˜åŒ–)
- [6. æœ€ä½³å®è·µ](#6-æœ€ä½³å®è·µ)

---

## 1. é—®é¢˜åˆ†æ

### 1.1 å¤§æ–‡ä»¶ä¸Šä¼ çš„æŒ‘æˆ˜

**ä¼ ç»Ÿä¸Šä¼ æ–¹å¼çš„é—®é¢˜**ï¼š

1. **å†…å­˜å ç”¨**ï¼šå¤§æ–‡ä»¶ä¸€æ¬¡æ€§åŠ è½½åˆ°å†…å­˜ï¼Œå¯èƒ½å¯¼è‡´æµè§ˆå™¨å´©æºƒ
2. **ç½‘ç»œè¶…æ—¶**ï¼šä¸Šä¼ æ—¶é—´è¿‡é•¿ï¼Œå®¹æ˜“è§¦å‘ç½‘ç»œè¶…æ—¶
3. **ä¸Šä¼ å¤±è´¥**ï¼šç½‘ç»œä¸­æ–­åéœ€è¦é‡æ–°ä¸Šä¼ æ•´ä¸ªæ–‡ä»¶
4. **ç”¨æˆ·ä½“éªŒ**ï¼šæ— æ³•æ˜¾ç¤ºä¸Šä¼ è¿›åº¦ï¼Œç”¨æˆ·ä½“éªŒå·®
5. **æœåŠ¡å™¨å‹åŠ›**ï¼šå¤§æ–‡ä»¶ä¸Šä¼ å¯¹æœåŠ¡å™¨é€ æˆå‹åŠ›

### 1.2 è§£å†³æ–¹æ¡ˆ

**åˆ†ç‰‡ä¸Šä¼ ï¼ˆChunk Uploadï¼‰**ï¼š
- å°†å¤§æ–‡ä»¶åˆ†å‰²æˆå¤šä¸ªå°ç‰‡æ®µ
- é€ä¸ªä¸Šä¼ æ–‡ä»¶ç‰‡æ®µ
- æœåŠ¡å™¨åˆå¹¶æ–‡ä»¶ç‰‡æ®µ

**æ–­ç‚¹ç»­ä¼ ï¼ˆResume Uploadï¼‰**ï¼š
- è®°å½•å·²ä¸Šä¼ çš„ç‰‡æ®µ
- ç½‘ç»œä¸­æ–­åä»æ–­ç‚¹ç»§ç»­ä¸Šä¼ 
- é¿å…é‡å¤ä¸Šä¼ 

**è¿›åº¦ç›‘æ§ï¼ˆProgress Monitoringï¼‰**ï¼š
- å®æ—¶æ˜¾ç¤ºä¸Šä¼ è¿›åº¦
- æ˜¾ç¤ºä¸Šä¼ é€Ÿåº¦
- é¢„ä¼°å‰©ä½™æ—¶é—´

---

## 2. æŠ€æœ¯æ–¹æ¡ˆ

### 2.1 æŠ€æœ¯æ ˆ

**å‰ç«¯æŠ€æœ¯**ï¼š
- File APIï¼šè·å–æ–‡ä»¶å¯¹è±¡
- Blob APIï¼šæ–‡ä»¶åˆ‡ç‰‡
- FileReader APIï¼šè¯»å–æ–‡ä»¶å†…å®¹ï¼ˆå¯é€‰ï¼‰
- XMLHttpRequest / Fetch APIï¼šå‘é€è¯·æ±‚
- Streams APIï¼šæµå¼å¤„ç†ï¼ˆå¯é€‰ï¼‰

**åç«¯æŠ€æœ¯**ï¼š
- æ¥æ”¶æ–‡ä»¶ç‰‡æ®µ
- éªŒè¯æ–‡ä»¶ç‰‡æ®µ
- åˆå¹¶æ–‡ä»¶ç‰‡æ®µ
- æ”¯æŒæ–­ç‚¹ç»­ä¼ 

### 2.2 å®ç°æµç¨‹

```
1. é€‰æ‹©æ–‡ä»¶
   â†“
2. è®¡ç®—æ–‡ä»¶ Hashï¼ˆMD5/SHA256ï¼‰
   â†“
3. æ£€æŸ¥æœåŠ¡å™¨æ˜¯å¦å·²æœ‰æ–‡ä»¶ï¼ˆç§’ä¼ ï¼‰
   â†“
4. åˆ†å‰²æ–‡ä»¶ä¸ºå¤šä¸ªç‰‡æ®µ
   â†“
5. ä¸Šä¼ æ–‡ä»¶ç‰‡æ®µï¼ˆå¹¶å‘/ä¸²è¡Œï¼‰
   â†“
6. æ˜¾ç¤ºä¸Šä¼ è¿›åº¦
   â†“
7. æ‰€æœ‰ç‰‡æ®µä¸Šä¼ å®Œæˆåï¼Œé€šçŸ¥æœåŠ¡å™¨åˆå¹¶
   â†“
8. ä¸Šä¼ å®Œæˆ
```

### 2.3 æ–‡ä»¶åˆ†ç‰‡ç­–ç•¥

**åˆ†ç‰‡å¤§å°**ï¼š
- æ¨èï¼š2MB - 5MB
- å¤ªå°ï¼šè¯·æ±‚æ¬¡æ•°è¿‡å¤šï¼Œæ•ˆç‡ä½
- å¤ªå¤§ï¼šç½‘ç»œä¸­æ–­åé‡ä¼ æˆæœ¬é«˜

**åˆ†ç‰‡å‘½å**ï¼š
- æ ¼å¼ï¼š`{fileHash}-{chunkIndex}-{totalChunks}`
- ç¤ºä¾‹ï¼š`abc123-0-10`ã€`abc123-1-10`

---

## 3. æ ¸å¿ƒå®ç°

### 3.1 æ–‡ä»¶åˆ‡ç‰‡

```javascript
/**
 * æ–‡ä»¶åˆ‡ç‰‡
 * @param {File} file - æ–‡ä»¶å¯¹è±¡
 * @param {number} chunkSize - åˆ‡ç‰‡å¤§å°ï¼ˆå­—èŠ‚ï¼‰
 * @returns {Array<Blob>} åˆ‡ç‰‡æ•°ç»„
 */
function createFileChunks(file, chunkSize = 2 * 1024 * 1024) {
  const chunks = [];
  let start = 0;
  
  while (start < file.size) {
    const end = Math.min(start + chunkSize, file.size);
    const chunk = file.slice(start, end);
    chunks.push(chunk);
    start = end;
  }
  
  return chunks;
}
```

### 3.2 è®¡ç®—æ–‡ä»¶ Hash

```javascript
/**
 * è®¡ç®—æ–‡ä»¶ Hashï¼ˆMD5ï¼‰
 * @param {File} file - æ–‡ä»¶å¯¹è±¡
 * @returns {Promise<string>} æ–‡ä»¶ Hash
 */
async function calculateFileHash(file) {
  return new Promise((resolve, reject) => {
    const chunkSize = 2 * 1024 * 1024; // 2MB
    const chunks = Math.ceil(file.size / chunkSize);
    const spark = new SparkMD5.ArrayBuffer();
    const fileReader = new FileReader();
    let currentChunk = 0;
    
    fileReader.onload = (e) => {
      spark.append(e.target.result);
      currentChunk++;
      
      if (currentChunk < chunks) {
        loadNext();
      } else {
        resolve(spark.end());
      }
    };
    
    fileReader.onerror = reject;
    
    function loadNext() {
      const start = currentChunk * chunkSize;
      const end = Math.min(start + chunkSize, file.size);
      fileReader.readAsArrayBuffer(file.slice(start, end));
    }
    
    loadNext();
  });
}

// ä½¿ç”¨ Web Crypto APIï¼ˆç°ä»£æµè§ˆå™¨ï¼‰
async function calculateFileHashWithCrypto(file) {
  const chunkSize = 2 * 1024 * 1024; // 2MB
  const chunks = Math.ceil(file.size / chunkSize);
  const hashBuffer = await crypto.subtle.digest('SHA-256', await file.arrayBuffer());
  const hashArray = Array.from(new Uint8Array(hashBuffer));
  return hashArray.map(b => b.toString(16).padStart(2, '0')).join('');
}
```

### 3.3 ä¸Šä¼ å•ä¸ªç‰‡æ®µ

```javascript
/**
 * ä¸Šä¼ æ–‡ä»¶ç‰‡æ®µ
 * @param {Blob} chunk - æ–‡ä»¶ç‰‡æ®µ
 * @param {number} chunkIndex - ç‰‡æ®µç´¢å¼•
 * @param {string} fileHash - æ–‡ä»¶ Hash
 * @param {string} fileName - æ–‡ä»¶åç§°
 * @param {number} totalChunks - æ€»ç‰‡æ®µæ•°
 * @returns {Promise<void>}
 */
async function uploadChunk(chunk, chunkIndex, fileHash, fileName, totalChunks) {
  const formData = new FormData();
  formData.append('chunk', chunk);
  formData.append('chunkIndex', chunkIndex);
  formData.append('fileHash', fileHash);
  formData.append('fileName', fileName);
  formData.append('totalChunks', totalChunks);
  
  return fetch('/api/upload/chunk', {
    method: 'POST',
    body: formData,
  }).then(response => {
    if (!response.ok) {
      throw new Error(`Upload failed: ${response.statusText}`);
    }
    return response.json();
  });
}
```

### 3.4 å¹¶å‘ä¸Šä¼ æ§åˆ¶

```javascript
/**
 * å¹¶å‘ä¸Šä¼ æ–‡ä»¶ç‰‡æ®µ
 * @param {Array<Blob>} chunks - æ–‡ä»¶ç‰‡æ®µæ•°ç»„
 * @param {string} fileHash - æ–‡ä»¶ Hash
 * @param {string} fileName - æ–‡ä»¶åç§°
 * @param {number} concurrency - å¹¶å‘æ•°
 * @param {Function} onProgress - è¿›åº¦å›è°ƒ
 * @returns {Promise<void>}
 */
async function uploadChunks(chunks, fileHash, fileName, concurrency = 3, onProgress) {
  const totalChunks = chunks.length;
  let uploadedChunks = 0;
  const uploadedIndexes = new Set();
  
  // è·å–å·²ä¸Šä¼ çš„ç‰‡æ®µç´¢å¼•
  const uploadedIndexesResponse = await fetch(`/api/upload/check?fileHash=${fileHash}`);
  const { uploadedIndexes: serverUploadedIndexes } = await uploadedIndexesResponse.json();
  serverUploadedIndexes.forEach(index => uploadedIndexes.add(index));
  uploadedChunks = uploadedIndexes.size;
  
  // æ›´æ–°è¿›åº¦
  onProgress?.({
    uploaded: uploadedChunks,
    total: totalChunks,
    percentage: (uploadedChunks / totalChunks) * 100,
  });
  
  // åˆ›å»ºä¸Šä¼ ä»»åŠ¡
  const uploadTasks = chunks
    .map((chunk, index) => ({
      chunk,
      index,
    }))
    .filter(({ index }) => !uploadedIndexes.has(index));
  
  // å¹¶å‘ä¸Šä¼ 
  const uploadPromises = [];
  let currentIndex = 0;
  
  async function uploadNext() {
    if (currentIndex >= uploadTasks.length) {
      return;
    }
    
    const { chunk, index } = uploadTasks[currentIndex++];
    
    try {
      await uploadChunk(chunk, index, fileHash, fileName, totalChunks);
      uploadedIndexes.add(index);
      uploadedChunks++;
      
      // æ›´æ–°è¿›åº¦
      onProgress?.({
        uploaded: uploadedChunks,
        total: totalChunks,
        percentage: (uploadedChunks / totalChunks) * 100,
      });
    } catch (error) {
      console.error(`Chunk ${index} upload failed:`, error);
      // é‡è¯•é€»è¾‘
      throw error;
    }
    
    // ç»§ç»­ä¸Šä¼ ä¸‹ä¸€ä¸ª
    await uploadNext();
  }
  
  // å¯åŠ¨å¹¶å‘ä¸Šä¼ 
  const concurrentPromises = Array.from({ length: concurrency }, () => uploadNext());
  await Promise.all(concurrentPromises);
  
  // æ‰€æœ‰ç‰‡æ®µä¸Šä¼ å®Œæˆåï¼Œé€šçŸ¥æœåŠ¡å™¨åˆå¹¶
  if (uploadedChunks === totalChunks) {
    await mergeChunks(fileHash, fileName);
  }
}

/**
 * åˆå¹¶æ–‡ä»¶ç‰‡æ®µ
 * @param {string} fileHash - æ–‡ä»¶ Hash
 * @param {string} fileName - æ–‡ä»¶åç§°
 * @returns {Promise<void>}
 */
async function mergeChunks(fileHash, fileName) {
  return fetch('/api/upload/merge', {
    method: 'POST',
    headers: {
      'Content-Type': 'application/json',
    },
    body: JSON.stringify({
      fileHash,
      fileName,
    }),
  }).then(response => {
    if (!response.ok) {
      throw new Error(`Merge failed: ${response.statusText}`);
    }
    return response.json();
  });
}
```

### 3.5 è¿›åº¦ç›‘æ§

```javascript
/**
 * ä¸Šä¼ è¿›åº¦ç›‘æ§
 */
class UploadProgress {
  constructor() {
    this.uploaded = 0;
    this.total = 0;
    this.speed = 0; // å­—èŠ‚/ç§’
    this.remainingTime = 0; // ç§’
    this.startTime = Date.now();
    this.lastUpdateTime = Date.now();
    this.lastUploaded = 0;
  }
  
  update(uploaded, total) {
    const now = Date.now();
    const timeDelta = (now - this.lastUpdateTime) / 1000; // ç§’
    const uploadedDelta = uploaded - this.lastUploaded;
    
    if (timeDelta > 0) {
      this.speed = uploadedDelta / timeDelta;
      const remaining = total - uploaded;
      this.remainingTime = remaining / this.speed;
    }
    
    this.uploaded = uploaded;
    this.total = total;
    this.lastUpdateTime = now;
    this.lastUploaded = uploaded;
  }
  
  getPercentage() {
    return this.total > 0 ? (this.uploaded / this.total) * 100 : 0;
  }
  
  formatSpeed() {
    if (this.speed < 1024) {
      return `${this.speed.toFixed(2)} B/s`;
    } else if (this.speed < 1024 * 1024) {
      return `${(this.speed / 1024).toFixed(2)} KB/s`;
    } else {
      return `${(this.speed / (1024 * 1024)).toFixed(2)} MB/s`;
    }
  }
  
  formatRemainingTime() {
    if (this.remainingTime < 60) {
      return `${Math.ceil(this.remainingTime)} ç§’`;
    } else if (this.remainingTime < 3600) {
      return `${Math.ceil(this.remainingTime / 60)} åˆ†é’Ÿ`;
    } else {
      return `${Math.ceil(this.remainingTime / 3600)} å°æ—¶`;
    }
  }
}
```

---

## 4. å®Œæ•´ Demo

### 4.1 HTML ç»“æ„

```html
<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>å¤§æ–‡ä»¶ä¸Šä¼  Demo</title>
  <style>
    .upload-container {
      max-width: 800px;
      margin: 50px auto;
      padding: 20px;
      border: 1px solid #ddd;
      border-radius: 8px;
    }
    
    .upload-area {
      border: 2px dashed #ccc;
      border-radius: 8px;
      padding: 40px;
      text-align: center;
      cursor: pointer;
      transition: border-color 0.3s;
    }
    
    .upload-area:hover {
      border-color: #1890ff;
    }
    
    .upload-area.dragover {
      border-color: #1890ff;
      background-color: #f0f7ff;
    }
    
    .file-input {
      display: none;
    }
    
    .file-list {
      margin-top: 20px;
    }
    
    .file-item {
      padding: 15px;
      border: 1px solid #eee;
      border-radius: 4px;
      margin-bottom: 10px;
    }
    
    .file-info {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 10px;
    }
    
    .file-name {
      font-weight: bold;
    }
    
    .file-size {
      color: #999;
    }
    
    .progress-bar {
      width: 100%;
      height: 20px;
      background-color: #f0f0f0;
      border-radius: 10px;
      overflow: hidden;
      margin-bottom: 5px;
    }
    
    .progress-fill {
      height: 100%;
      background-color: #1890ff;
      transition: width 0.3s;
    }
    
    .progress-info {
      display: flex;
      justify-content: space-between;
      font-size: 12px;
      color: #666;
    }
    
    .btn {
      padding: 8px 16px;
      border: none;
      border-radius: 4px;
      cursor: pointer;
      margin-right: 10px;
    }
    
    .btn-primary {
      background-color: #1890ff;
      color: white;
    }
    
    .btn-danger {
      background-color: #ff4d4f;
      color: white;
    }
  </style>
</head>
<body>
  <div class="upload-container">
    <h1>å¤§æ–‡ä»¶ä¸Šä¼  Demo</h1>
    
    <div class="upload-area" id="uploadArea">
      <p>ç‚¹å‡»æˆ–æ‹–æ‹½æ–‡ä»¶åˆ°æ­¤åŒºåŸŸä¸Šä¼ </p>
      <input type="file" id="fileInput" class="file-input" multiple>
    </div>
    
    <div class="file-list" id="fileList"></div>
  </div>
  
  <script src="https://cdn.jsdelivr.net/npm/spark-md5@3.0.2/spark-md5.min.js"></script>
  <script src="upload.js"></script>
</body>
</html>
```

### 4.2 JavaScript å®ç°

```javascript
// upload.js

class LargeFileUploader {
  constructor(options = {}) {
    this.chunkSize = options.chunkSize || 2 * 1024 * 1024; // 2MB
    this.concurrency = options.concurrency || 3; // å¹¶å‘æ•°
    this.uploadUrl = options.uploadUrl || '/api/upload/chunk';
    this.mergeUrl = options.mergeUrl || '/api/upload/merge';
    this.checkUrl = options.checkUrl || '/api/upload/check';
    this.files = new Map(); // æ–‡ä»¶åˆ—è¡¨
  }
  
  /**
   * åˆå§‹åŒ–
   */
  init() {
    const uploadArea = document.getElementById('uploadArea');
    const fileInput = document.getElementById('fileInput');
    
    // ç‚¹å‡»ä¸Šä¼ åŒºåŸŸ
    uploadArea.addEventListener('click', () => {
      fileInput.click();
    });
    
    // æ–‡ä»¶é€‰æ‹©
    fileInput.addEventListener('change', (e) => {
      this.handleFiles(Array.from(e.target.files));
    });
    
    // æ‹–æ‹½ä¸Šä¼ 
    uploadArea.addEventListener('dragover', (e) => {
      e.preventDefault();
      uploadArea.classList.add('dragover');
    });
    
    uploadArea.addEventListener('dragleave', () => {
      uploadArea.classList.remove('dragover');
    });
    
    uploadArea.addEventListener('drop', (e) => {
      e.preventDefault();
      uploadArea.classList.remove('dragover');
      this.handleFiles(Array.from(e.dataTransfer.files));
    });
  }
  
  /**
   * å¤„ç†æ–‡ä»¶
   */
  async handleFiles(files) {
    for (const file of files) {
      await this.addFile(file);
    }
  }
  
  /**
   * æ·»åŠ æ–‡ä»¶
   */
  async addFile(file) {
    const fileId = `${file.name}-${file.size}-${file.lastModified}`;
    
    if (this.files.has(fileId)) {
      console.warn('File already exists:', file.name);
      return;
    }
    
    const fileItem = {
      id: fileId,
      file,
      status: 'pending', // pending, hashing, uploading, success, error
      progress: 0,
      speed: 0,
      remainingTime: 0,
      hash: null,
      chunks: null,
    };
    
    this.files.set(fileId, fileItem);
    this.renderFileItem(fileItem);
    
    // å¼€å§‹ä¸Šä¼ 
    this.uploadFile(fileItem);
  }
  
  /**
   * ä¸Šä¼ æ–‡ä»¶
   */
  async uploadFile(fileItem) {
    try {
      // 1. è®¡ç®—æ–‡ä»¶ Hash
      fileItem.status = 'hashing';
      this.updateFileItem(fileItem);
      fileItem.hash = await this.calculateFileHash(fileItem.file);
      
      // 2. æ£€æŸ¥æœåŠ¡å™¨æ˜¯å¦å·²æœ‰æ–‡ä»¶ï¼ˆç§’ä¼ ï¼‰
      const checkResult = await this.checkFile(fileItem.hash);
      if (checkResult.exists) {
        fileItem.status = 'success';
        fileItem.progress = 100;
        this.updateFileItem(fileItem);
        return;
      }
      
      // 3. åˆ†å‰²æ–‡ä»¶
      fileItem.chunks = this.createFileChunks(fileItem.file);
      
      // 4. ä¸Šä¼ æ–‡ä»¶ç‰‡æ®µ
      fileItem.status = 'uploading';
      this.updateFileItem(fileItem);
      
      const progress = new UploadProgress();
      await this.uploadChunks(
        fileItem.chunks,
        fileItem.hash,
        fileItem.file.name,
        (progressData) => {
          progress.update(progressData.uploaded * this.chunkSize, fileItem.file.size);
          fileItem.progress = progress.getPercentage();
          fileItem.speed = progress.speed;
          fileItem.remainingTime = progress.remainingTime;
          this.updateFileItem(fileItem);
        }
      );
      
      // 5. åˆå¹¶æ–‡ä»¶ç‰‡æ®µ
      await this.mergeChunks(fileItem.hash, fileItem.file.name);
      
      fileItem.status = 'success';
      fileItem.progress = 100;
      this.updateFileItem(fileItem);
    } catch (error) {
      console.error('Upload failed:', error);
      fileItem.status = 'error';
      fileItem.error = error.message;
      this.updateFileItem(fileItem);
    }
  }
  
  /**
   * è®¡ç®—æ–‡ä»¶ Hash
   */
  async calculateFileHash(file) {
    return new Promise((resolve, reject) => {
      const chunkSize = 2 * 1024 * 1024; // 2MB
      const chunks = Math.ceil(file.size / chunkSize);
      const spark = new SparkMD5.ArrayBuffer();
      const fileReader = new FileReader();
      let currentChunk = 0;
      
      fileReader.onload = (e) => {
        spark.append(e.target.result);
        currentChunk++;
        
        if (currentChunk < chunks) {
          loadNext();
        } else {
          resolve(spark.end());
        }
      };
      
      fileReader.onerror = reject;
      
      function loadNext() {
        const start = currentChunk * chunkSize;
        const end = Math.min(start + chunkSize, file.size);
        fileReader.readAsArrayBuffer(file.slice(start, end));
      }
      
      loadNext();
    });
  }
  
  /**
   * æ£€æŸ¥æ–‡ä»¶æ˜¯å¦å­˜åœ¨
   */
  async checkFile(fileHash) {
    const response = await fetch(`${this.checkUrl}?fileHash=${fileHash}`);
    return response.json();
  }
  
  /**
   * åˆ›å»ºæ–‡ä»¶åˆ‡ç‰‡
   */
  createFileChunks(file) {
    const chunks = [];
    let start = 0;
    
    while (start < file.size) {
      const end = Math.min(start + this.chunkSize, file.size);
      const chunk = file.slice(start, end);
      chunks.push(chunk);
      start = end;
    }
    
    return chunks;
  }
  
  /**
   * ä¸Šä¼ æ–‡ä»¶ç‰‡æ®µ
   */
  async uploadChunks(chunks, fileHash, fileName, onProgress) {
    const totalChunks = chunks.length;
    let uploadedChunks = 0;
    const uploadedIndexes = new Set();
    
    // è·å–å·²ä¸Šä¼ çš„ç‰‡æ®µç´¢å¼•
    try {
      const response = await fetch(`${this.checkUrl}?fileHash=${fileHash}`);
      const { uploadedIndexes: serverUploadedIndexes } = await response.json();
      serverUploadedIndexes.forEach(index => uploadedIndexes.add(index));
      uploadedChunks = uploadedIndexes.size;
      onProgress?.({ uploaded: uploadedChunks, total: totalChunks });
    } catch (error) {
      console.warn('Failed to check uploaded chunks:', error);
    }
    
    // åˆ›å»ºä¸Šä¼ ä»»åŠ¡
    const uploadTasks = chunks
      .map((chunk, index) => ({ chunk, index }))
      .filter(({ index }) => !uploadedIndexes.has(index));
    
    // å¹¶å‘ä¸Šä¼ 
    const semaphore = new Semaphore(this.concurrency);
    const uploadPromises = uploadTasks.map(({ chunk, index }) =>
      semaphore.acquire().then(async (release) => {
        try {
          await this.uploadChunk(chunk, index, fileHash, fileName, totalChunks);
          uploadedIndexes.add(index);
          uploadedChunks++;
          onProgress?.({ uploaded: uploadedChunks, total: totalChunks });
        } finally {
          release();
        }
      })
    );
    
    await Promise.all(uploadPromises);
  }
  
  /**
   * ä¸Šä¼ å•ä¸ªç‰‡æ®µ
   */
  async uploadChunk(chunk, chunkIndex, fileHash, fileName, totalChunks) {
    const formData = new FormData();
    formData.append('chunk', chunk);
    formData.append('chunkIndex', chunkIndex);
    formData.append('fileHash', fileHash);
    formData.append('fileName', fileName);
    formData.append('totalChunks', totalChunks);
    
    const response = await fetch(this.uploadUrl, {
      method: 'POST',
      body: formData,
    });
    
    if (!response.ok) {
      throw new Error(`Upload failed: ${response.statusText}`);
    }
    
    return response.json();
  }
  
  /**
   * åˆå¹¶æ–‡ä»¶ç‰‡æ®µ
   */
  async mergeChunks(fileHash, fileName) {
    const response = await fetch(this.mergeUrl, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
      },
      body: JSON.stringify({
        fileHash,
        fileName,
      }),
    });
    
    if (!response.ok) {
      throw new Error(`Merge failed: ${response.statusText}`);
    }
    
    return response.json();
  }
  
  /**
   * æ¸²æŸ“æ–‡ä»¶é¡¹
   */
  renderFileItem(fileItem) {
    const fileList = document.getElementById('fileList');
    const fileItemEl = document.createElement('div');
    fileItemEl.className = 'file-item';
    fileItemEl.id = `file-${fileItem.id}`;
    fileItemEl.innerHTML = `
      <div class="file-info">
        <span class="file-name">${fileItem.file.name}</span>
        <span class="file-size">${this.formatFileSize(fileItem.file.size)}</span>
      </div>
      <div class="progress-bar">
        <div class="progress-fill" style="width: ${fileItem.progress}%"></div>
      </div>
      <div class="progress-info">
        <span>${fileItem.status}</span>
        <span>${fileItem.progress.toFixed(2)}%</span>
        <span>${this.formatSpeed(fileItem.speed)}</span>
        <span>${this.formatRemainingTime(fileItem.remainingTime)}</span>
      </div>
    `;
    fileList.appendChild(fileItemEl);
  }
  
  /**
   * æ›´æ–°æ–‡ä»¶é¡¹
   */
  updateFileItem(fileItem) {
    const fileItemEl = document.getElementById(`file-${fileItem.id}`);
    if (!fileItemEl) return;
    
    const progressFill = fileItemEl.querySelector('.progress-fill');
    const progressInfo = fileItemEl.querySelector('.progress-info');
    
    if (progressFill) {
      progressFill.style.width = `${fileItem.progress}%`;
    }
    
    if (progressInfo) {
      progressInfo.innerHTML = `
        <span>${fileItem.status}</span>
        <span>${fileItem.progress.toFixed(2)}%</span>
        <span>${this.formatSpeed(fileItem.speed)}</span>
        <span>${this.formatRemainingTime(fileItem.remainingTime)}</span>
      `;
    }
  }
  
  /**
   * æ ¼å¼åŒ–æ–‡ä»¶å¤§å°
   */
  formatFileSize(bytes) {
    if (bytes < 1024) return bytes + ' B';
    if (bytes < 1024 * 1024) return (bytes / 1024).toFixed(2) + ' KB';
    if (bytes < 1024 * 1024 * 1024) return (bytes / (1024 * 1024)).toFixed(2) + ' MB';
    return (bytes / (1024 * 1024 * 1024)).toFixed(2) + ' GB';
  }
  
  /**
   * æ ¼å¼åŒ–é€Ÿåº¦
   */
  formatSpeed(speed) {
    if (speed < 1024) return speed.toFixed(2) + ' B/s';
    if (speed < 1024 * 1024) return (speed / 1024).toFixed(2) + ' KB/s';
    return (speed / (1024 * 1024)).toFixed(2) + ' MB/s';
  }
  
  /**
   * æ ¼å¼åŒ–å‰©ä½™æ—¶é—´
   */
  formatRemainingTime(seconds) {
    if (seconds < 60) return Math.ceil(seconds) + ' ç§’';
    if (seconds < 3600) return Math.ceil(seconds / 60) + ' åˆ†é’Ÿ';
    return Math.ceil(seconds / 3600) + ' å°æ—¶';
  }
}

/**
 * ä¿¡å·é‡ï¼ˆæ§åˆ¶å¹¶å‘ï¼‰
 */
class Semaphore {
  constructor(count) {
    this.count = count;
    this.waiting = [];
  }
  
  acquire() {
    return new Promise((resolve) => {
      if (this.count > 0) {
        this.count--;
        resolve(() => {
          this.count++;
          if (this.waiting.length > 0) {
            const next = this.waiting.shift();
            this.count--;
            next();
          }
        });
      } else {
        this.waiting.push(() => {
          resolve(() => {
            this.count++;
            if (this.waiting.length > 0) {
              const next = this.waiting.shift();
              this.count--;
              next();
            }
          });
        });
      }
    });
  }
}

/**
 * ä¸Šä¼ è¿›åº¦
 */
class UploadProgress {
  constructor() {
    this.uploaded = 0;
    this.total = 0;
    this.speed = 0;
    this.remainingTime = 0;
    this.lastUpdateTime = Date.now();
    this.lastUploaded = 0;
  }
  
  update(uploaded, total) {
    const now = Date.now();
    const timeDelta = (now - this.lastUpdateTime) / 1000;
    const uploadedDelta = uploaded - this.lastUploaded;
    
    if (timeDelta > 0) {
      this.speed = uploadedDelta / timeDelta;
      const remaining = total - uploaded;
      this.remainingTime = remaining / this.speed;
    }
    
    this.uploaded = uploaded;
    this.total = total;
    this.lastUpdateTime = now;
    this.lastUploaded = uploaded;
  }
  
  getPercentage() {
    return this.total > 0 ? (this.uploaded / this.total) * 100 : 0;
  }
}

// åˆå§‹åŒ–
const uploader = new LargeFileUploader({
  chunkSize: 2 * 1024 * 1024, // 2MB
  concurrency: 3, // å¹¶å‘æ•°
  uploadUrl: '/api/upload/chunk',
  mergeUrl: '/api/upload/merge',
  checkUrl: '/api/upload/check',
});

uploader.init();
```

### 4.3 åç«¯æ¥å£ç¤ºä¾‹ï¼ˆNode.jsï¼‰

```javascript
// server.js (Express)

const express = require('express');
const multer = require('multer');
const fs = require('fs');
const path = require('path');
const crypto = require('crypto');

const app = express();
const upload = multer({ dest: 'uploads/chunks/' });

// å­˜å‚¨æ–‡ä»¶ä¿¡æ¯
const fileInfo = new Map();

// ä¸Šä¼ æ–‡ä»¶ç‰‡æ®µ
app.post('/api/upload/chunk', upload.single('chunk'), (req, res) => {
  const { chunkIndex, fileHash, fileName, totalChunks } = req.body;
  const chunk = req.file;
  
  // ä¿å­˜æ–‡ä»¶ä¿¡æ¯
  if (!fileInfo.has(fileHash)) {
    fileInfo.set(fileHash, {
      fileName,
      totalChunks: parseInt(totalChunks),
      chunks: new Set(),
    });
  }
  
  const info = fileInfo.get(fileHash);
  info.chunks.add(parseInt(chunkIndex));
  
  // é‡å‘½åæ–‡ä»¶ç‰‡æ®µ
  const chunkPath = path.join('uploads/chunks', `${fileHash}-${chunkIndex}`);
  fs.renameSync(chunk.path, chunkPath);
  
  res.json({
    success: true,
    chunkIndex: parseInt(chunkIndex),
  });
});

// æ£€æŸ¥æ–‡ä»¶æ˜¯å¦å­˜åœ¨
app.get('/api/upload/check', (req, res) => {
  const { fileHash } = req.query;
  
  // æ£€æŸ¥æ–‡ä»¶æ˜¯å¦å·²å­˜åœ¨
  const filePath = path.join('uploads', fileHash);
  if (fs.existsSync(filePath)) {
    return res.json({
      exists: true,
      filePath,
    });
  }
  
  // æ£€æŸ¥å·²ä¸Šä¼ çš„ç‰‡æ®µ
  const info = fileInfo.get(fileHash);
  if (info) {
    return res.json({
      exists: false,
      uploadedIndexes: Array.from(info.chunks),
    });
  }
  
  res.json({
    exists: false,
    uploadedIndexes: [],
  });
});

// åˆå¹¶æ–‡ä»¶ç‰‡æ®µ
app.post('/api/upload/merge', (req, res) => {
  const { fileHash, fileName } = req.body;
  const info = fileInfo.get(fileHash);
  
  if (!info || info.chunks.size !== info.totalChunks) {
    return res.status(400).json({
      success: false,
      message: 'Not all chunks uploaded',
    });
  }
  
  // åˆå¹¶æ–‡ä»¶ç‰‡æ®µ
  const filePath = path.join('uploads', fileHash);
  const writeStream = fs.createWriteStream(filePath);
  
  for (let i = 0; i < info.totalChunks; i++) {
    const chunkPath = path.join('uploads/chunks', `${fileHash}-${i}`);
    const chunkData = fs.readFileSync(chunkPath);
    writeStream.write(chunkData);
    fs.unlinkSync(chunkPath); // åˆ é™¤ç‰‡æ®µ
  }
  
  writeStream.end();
  
  // åˆ é™¤æ–‡ä»¶ä¿¡æ¯
  fileInfo.delete(fileHash);
  
  res.json({
    success: true,
    filePath,
  });
});

app.listen(3000, () => {
  console.log('Server running on http://localhost:3000');
});
```

---

## 5. è¿›é˜¶ä¼˜åŒ–

### 5.1 Web Workers è®¡ç®— Hash

```javascript
// hash-worker.js
self.onmessage = function(e) {
  const { file, chunkSize } = e.data;
  const chunks = Math.ceil(file.size / chunkSize);
  const spark = new SparkMD5.ArrayBuffer();
  const fileReader = new FileReader();
  let currentChunk = 0;
  
  fileReader.onload = function(e) {
    spark.append(e.target.result);
    currentChunk++;
    
    self.postMessage({
      progress: (currentChunk / chunks) * 100,
    });
    
    if (currentChunk < chunks) {
      loadNext();
    } else {
      self.postMessage({
        hash: spark.end(),
        progress: 100,
      });
    }
  };
  
  fileReader.onerror = function(error) {
    self.postMessage({
      error: error.message,
    });
  };
  
  function loadNext() {
    const start = currentChunk * chunkSize;
    const end = Math.min(start + chunkSize, file.size);
    fileReader.readAsArrayBuffer(file.slice(start, end));
  }
  
  loadNext();
};

// ä½¿ç”¨
const worker = new Worker('hash-worker.js');
worker.postMessage({ file, chunkSize: 2 * 1024 * 1024 });
worker.onmessage = function(e) {
  const { hash, progress, error } = e.data;
  if (error) {
    console.error('Hash calculation failed:', error);
  } else if (hash) {
    console.log('File hash:', hash);
  } else {
    console.log('Progress:', progress);
  }
};
```

### 5.2 ä½¿ç”¨ Streams API

```javascript
/**
 * ä½¿ç”¨ Streams API ä¸Šä¼ æ–‡ä»¶
 */
async function uploadFileWithStream(file) {
  const reader = file.stream().getReader();
  const fileHash = await calculateFileHash(file);
  let chunkIndex = 0;
  
  while (true) {
    const { done, value } = await reader.read();
    if (done) break;
    
    const chunk = new Blob([value]);
    await uploadChunk(chunk, chunkIndex++, fileHash, file.name);
  }
}
```

### 5.3 å‹ç¼©ä¸Šä¼ 

```javascript
/**
 * å‹ç¼©åä¸Šä¼ 
 */
async function uploadCompressedFile(file) {
  // ä½¿ç”¨ compression-streams APIï¼ˆå®éªŒæ€§ï¼‰
  const compressionStream = new CompressionStream('gzip');
  const compressedStream = file.stream().pipeThrough(compressionStream);
  const compressedFile = await new Response(compressedStream).blob();
  
  // ä¸Šä¼ å‹ç¼©åçš„æ–‡ä»¶
  await uploadFile(compressedFile);
}
```

### 5.4 å›¾ç‰‡é¢„è§ˆå’Œå‹ç¼©

```javascript
/**
 * å›¾ç‰‡é¢„è§ˆå’Œå‹ç¼©
 */
function compressImage(file, maxWidth = 1920, quality = 0.8) {
  return new Promise((resolve, reject) => {
    const reader = new FileReader();
    reader.onload = (e) => {
      const img = new Image();
      img.onload = () => {
        const canvas = document.createElement('canvas');
        let width = img.width;
        let height = img.height;
        
        if (width > maxWidth) {
          height = (height * maxWidth) / width;
          width = maxWidth;
        }
        
        canvas.width = width;
        canvas.height = height;
        
        const ctx = canvas.getContext('2d');
        ctx.drawImage(img, 0, 0, width, height);
        
        canvas.toBlob(resolve, 'image/jpeg', quality);
      };
      img.onerror = reject;
      img.src = e.target.result;
    };
    reader.onerror = reject;
    reader.readAsDataURL(file);
  });
}
```

---

## 6. æœ€ä½³å®è·µ

### 6.1 é”™è¯¯å¤„ç†

```javascript
/**
 * é‡è¯•æœºåˆ¶
 */
async function uploadChunkWithRetry(chunk, chunkIndex, fileHash, fileName, totalChunks, maxRetries = 3) {
  let retries = 0;
  
  while (retries < maxRetries) {
    try {
      await uploadChunk(chunk, chunkIndex, fileHash, fileName, totalChunks);
      return;
    } catch (error) {
      retries++;
      if (retries >= maxRetries) {
        throw error;
      }
      await new Promise(resolve => setTimeout(resolve, 1000 * retries)); // æŒ‡æ•°é€€é¿
    }
  }
}
```

### 6.2 å–æ¶ˆä¸Šä¼ 

```javascript
/**
 * å¯å–æ¶ˆçš„ä¸Šä¼ 
 */
class CancellableUpload {
  constructor() {
    this.cancelled = false;
    this.abortController = new AbortController();
  }
  
  cancel() {
    this.cancelled = true;
    this.abortController.abort();
  }
  
  async uploadChunk(chunk, chunkIndex, fileHash, fileName, totalChunks) {
    if (this.cancelled) {
      throw new Error('Upload cancelled');
    }
    
    const formData = new FormData();
    formData.append('chunk', chunk);
    formData.append('chunkIndex', chunkIndex);
    formData.append('fileHash', fileHash);
    formData.append('fileName', fileName);
    formData.append('totalChunks', totalChunks);
    
    return fetch('/api/upload/chunk', {
      method: 'POST',
      body: formData,
      signal: this.abortController.signal,
    });
  }
}
```

### 6.3 æ€§èƒ½ä¼˜åŒ–

1. **åˆç†è®¾ç½®åˆ†ç‰‡å¤§å°**ï¼šæ ¹æ®ç½‘ç»œçŠ¶å†µåŠ¨æ€è°ƒæ•´
2. **æ§åˆ¶å¹¶å‘æ•°**ï¼šé¿å…è¿‡å¤šå¹¶å‘è¯·æ±‚
3. **ä½¿ç”¨ Web Workers**ï¼šå°† Hash è®¡ç®—ç§»åˆ° Worker çº¿ç¨‹
4. **ä½¿ç”¨ IndexedDB**ï¼šç¼“å­˜æ–‡ä»¶ä¿¡æ¯å’Œä¸Šä¼ çŠ¶æ€
5. **ä½¿ç”¨ Service Worker**ï¼šæ”¯æŒç¦»çº¿ä¸Šä¼ 

### 6.4 å®‰å…¨æ€§

1. **æ–‡ä»¶ç±»å‹éªŒè¯**ï¼šæ£€æŸ¥æ–‡ä»¶ MIME ç±»å‹å’Œæ‰©å±•å
2. **æ–‡ä»¶å¤§å°é™åˆ¶**ï¼šé™åˆ¶å•ä¸ªæ–‡ä»¶å’Œæ€»æ–‡ä»¶å¤§å°
3. **æ–‡ä»¶åè¿‡æ»¤**ï¼šé˜²æ­¢è·¯å¾„éå†æ”»å‡»
4. **HTTPS**ï¼šä½¿ç”¨ HTTPS ä¼ è¾“æ–‡ä»¶
5. **Token éªŒè¯**ï¼šä¸Šä¼ å‰éªŒè¯ç”¨æˆ·èº«ä»½

---

## ğŸ”— ç›¸å…³é“¾æ¥

### å‰ç½®çŸ¥è¯†
- [File API](../00-å‰ç«¯ä½“ç³»/01-åŸºç¡€å…¥é—¨/JavaScript/08-æµè§ˆå™¨ç¯å¢ƒä¸DOM/File-API.md) â€” æ–‡ä»¶å¯¹è±¡æ“ä½œ
- [Blob API](../00-å‰ç«¯ä½“ç³»/01-åŸºç¡€å…¥é—¨/JavaScript/08-æµè§ˆå™¨ç¯å¢ƒä¸DOM/Blob-API.md) â€” äºŒè¿›åˆ¶å¤§å¯¹è±¡
- [FileReader API](../00-å‰ç«¯ä½“ç³»/01-åŸºç¡€å…¥é—¨/JavaScript/08-æµè§ˆå™¨ç¯å¢ƒä¸DOM/FileReader-API.md) â€” æ–‡ä»¶è¯»å–
- [FormData API](../00-å‰ç«¯ä½“ç³»/01-åŸºç¡€å…¥é—¨/JavaScript/08-æµè§ˆå™¨ç¯å¢ƒä¸DOM/FormData-API.md) â€” è¡¨å•æ•°æ®å’Œæ–‡ä»¶ä¸Šä¼ 
- [Fetch API](../00-å‰ç«¯ä½“ç³»/01-åŸºç¡€å…¥é—¨/JavaScript/08-æµè§ˆå™¨ç¯å¢ƒä¸DOM/æµè§ˆå™¨API.md) â€” ç½‘ç»œè¯·æ±‚

### è¿›é˜¶å­¦ä¹ 
- [Web Workers](../00-å‰ç«¯ä½“ç³»/01-åŸºç¡€å…¥é—¨/JavaScript/08-æµè§ˆå™¨ç¯å¢ƒä¸DOM/æµè§ˆå™¨API.md) â€” å¤šçº¿ç¨‹å¤„ç†
- [IndexedDB](../00-å‰ç«¯ä½“ç³»/01-åŸºç¡€å…¥é—¨/JavaScript/08-æµè§ˆå™¨ç¯å¢ƒä¸DOM/æµè§ˆå™¨API.md) â€” å®¢æˆ·ç«¯å­˜å‚¨
- [Service Worker](../00-å‰ç«¯ä½“ç³»/05-é«˜çº§åº”ç”¨/ç½‘ç»œä¸ä¼ è¾“/!MOC-ç½‘ç»œä¸ä¼ è¾“.md) â€” ç¦»çº¿æ”¯æŒ

---

**æœ€åæ›´æ–°**ï¼š2025  
**ç»´æŠ¤è§„èŒƒ**ï¼šæ¯æ¬¡æ›´æ–°åï¼ŒåŒæ­¥æ›´æ–°ç›¸å…³ API æ–‡æ¡£

---

#å‰ç«¯ #æ–‡ä»¶ä¸Šä¼  #å¤§æ–‡ä»¶ä¸Šä¼  #åˆ†ç‰‡ä¸Šä¼  #æ–­ç‚¹ç»­ä¼  #FileAPI #BlobAPI #FileReaderAPI #StreamsAPI

