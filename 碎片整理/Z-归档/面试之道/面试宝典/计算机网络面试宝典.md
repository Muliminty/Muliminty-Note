[TOC]

# 计算机网络面试宝典

## HTTP

### HTTP1.1 HTTP2 HTTP3 的区别

#### HTTP1.0/HTTP1.1

+ HTTP是浏览器和服务器的通信语言
+ 诞生之初的HTTP/0.9因为需求简单，所以和服务器之间的通信过程也相对简单。
+ HTTP/1.0引入了请求头和响应头，主要是为了支持多种类型的文件下载；其次，还提供了Cache机制、用户代理、状态码等基础信息。
+ 随着技术和需求的发展，人们对文件传输的速度要求越来越高，故又基于HTTP/1.0推出了HTTP/1.1，增加了持久连接方法来提升连接效率，同时还尝试使用管线化技术提升效率(不过由于各种原因，管线化技术 最终被各大厂商放弃了)。除此之外，HTTP/1.1还引入了Cookie、虚拟主机的支持、对动态内容的支持等特性。

#### HTTP1.1和HTTP2的区别

http1.1升级之后的缺陷
虽然HTTP/1.1采取了很多优化资源加载速度的策略，也取得了一定的效果，但是HTTP/1.1对带宽的利用率却并不理想，这也是HTTP/1.1的一个核心问题。

+ 第一个原因，TCP的慢启动。
+ 第二个原因，同时开启了多条TCP连接，那么这些连接会竞争固定的带宽。
+ 第三个原因，HTTP/1.1队头阻塞的问题。

> HTTP/1.1所存在的一些主要问题: 慢启动和TCP连接之间相互竞争带宽是由于TCP本身的机制导致的，而队头阻塞是由于HTTP/1.1的机制导致的。

**http2的改进方法（多路复用）**
所以，HTTP/2的解决方案可以总结为:一个域名只使用一个TCP连接和消除队头阻塞问题

> 原文地址：
> [HTTP1、HTTP2、HTTP3 - 掘金](https://juejin.cn/post/6855470356657307662#heading-14)

### 说一下 http 和 https 的区别

#### 什么是HTTP

HTTP 超文本传输协议 ，应用层协议。主要用于 Web 上传输超媒体文本的底层协议，经常在浏览器和服务器之间传递数据。通信就是以纯本的形式进行。  

**HTTP是无状态的**

无状态是 HTTP 协议对客户端请求状态没有进行存储，比如每次请求都需要重新登录  

**HTTP是无连接的**

无连接主要是限制每次连接只处理一个请求。每次请求都是客户发起请求，服务端响应请求，然后就断开连接。
这期间就是通过三次握手建立连接，四次挥手断开连接。每次请求即便是多次请求并请求同一个资源，服务端都无法判断是否是相同请求，都需要重新响应请求。
所以，为了解决客户端和服务端保持会话连接，通过 cookie 和 session 来记录 http 状态。
HTTP 的其他特点是简单快速，只需传送方法和路径就可以向服务端进行请求；还有支持传输任意类型的数据对象。

#### 什么是HTTPS

https 是 http 的“升级”版本：`HTTPS = HTTP+ SSL/TLS`
SSL 是安全层，TLS 是传输层安全，是SSL 的继承。使用SSL或TLS 可确保传输数据的安全性。
使用 HTTP 可能看到传输数据是： “这是明文信息”
使用 HTTPS 可能看到： “283hd9saj9cdsncihquhs99ndso”
HTTPS 传输的不再是文本，而是二进制流，使得传输更高效，且加密处理更加安全。

#### HTTPS 的工作流程

+ 客户端请求 HTTPS 请求并连接到服务器的 443 端口，此过程和请求 HTTP 请求一样，进行三次握手；
+ 服务端向客户端发送数字证书，其中包含公钥、证书颁发者、到期日期
现比较流行的加解密码对，即公钥和私钥。公钥用于加密，私钥用于解密。所以服务端会保留私钥，然后发送公钥给客户端。
+ 客户端收到证书，会验证证书的有效性。验证通过后会生成一个随机的 pre-master key。再将密钥通过接收到的公钥加密然后发送给服务端
+ 服务端接收后使用私钥进行解密得到 pre-master key
+ 获得 pre-master key 后，服务器和客户端可以使用主密钥进行通信。

#### 总结

所以在回答 HTTP 与 HTTPS 的区别的问题，可以从下面几个方面进行回答：

+ 加密： HTTPS 是 HTTP 协议的更加安全的版本，通过使用SSL/TLS进行加密传输的数据；
+ 连接方式： HTTP（三次握手）和 HTTPS （三次握手+数字证书）连接方式不一样；
+ 端口： HTTP 默认的端口是 80和 HTTPS 默认端口是 443

## 网络安全

### 常见的网络攻击

> 我们常见的Web攻击方式有：
>
> + XSS (Cross Site Scripting) 跨站脚本攻击
> + CSRF（Cross-site request forgery）跨站请求伪造
> + SQL注入攻击

#### XSS

XSS，跨站脚本攻击，允许攻击者将恶意代码植入到提供给其它用户使用的页面中。

#### CSRF

CSRF（Cross-site request forgery）跨站请求伪造：攻击者诱导受害者进入第三方网站，在第三方网站中，向被攻击网站发送跨站请求

#### SQL注入

Sql 注入攻击，是通过将恶意的 Sql查询或添加语句插入到应用的输入参数中，再在后台 Sql服务器上解析执行进行的攻击

#### DNS劫持

#### DOS攻击与DDOS攻击

> 参考链接 :
>> [掘金 -- 网络攻击的常见形式以及防御措施 -- 别救了这猴子废了](https://juejin.cn/post/7119418482508169246#heading-9)
>
>> [哔哩哔哩 -- 黑客是如何找到漏洞，并发起DDoS攻击的？-- 技术蛋老师](https://www.bilibili.com/video/BV1z34y1v7aD/?spm_id_from=333.337.search-card.all.click&vd_source=55188e441990ee2ff1e28fae2d46edc2)

## 性能优化

### 缓存的工作原理

我们请求资源需要看看自己有没有缓存，如果没有缓存就问服务器索取，如果有缓存，就要检查缓存的新鲜度，查看缓存是否过期，如果缓存是新鲜的，没有过期就可以直接使用。如果缓存是不新鲜的过期了，就得和服务器进行验证。如果服务器告知没有过期，那就可以继续使用缓存。如果服务器告知已经过期，那就返回新的资源作为新的缓存。

**http请求头里面有两个控制缓存的首部 Pragma(逐渐被抛弃) 和 Cahace-Contorl**

```http
// no-cache 表示可以进行缓存，但是每次使用前都要和服务器进行确认，这个值容易和no-store混淆，no-store就是表示让浏然器不要缓存了，每次都像服务器请求资源
Cahace-Contorl :  no-cache 
// max-age 就表示资源的最长缓存时间，这里的单位是秒，在数值足够大的话，这表示资源是长期不需要改变的因此浏然器或者cdn都可以长期存储该资源
Cahace-Contorl :  max-age 1111111111


```

http 请求头其他缓存相关

+ etag：用来标识资源的，一般来说每一次资源更新后，etag的值也会被服务器更新。

+ Expries：表示缓存时间的首部，相当于缓存的过期时间，在过期事件没有到达之前都是认为资源未过期，因此不会和服务器要求更新资源，但是如果服务器的时间不同步，那时间就会出现误差，因此Expries经常和Last-modified配合使用

+ Last-modified：表示缓存时间的首部，表示资源最后修改时间，这样客户端下一次进行请求时就可以检查资源时间是否一致，如果一致就表示资源没有修改，如果不一致就得让服务器返回新的资源了

### 什么是强缓存

强缓存
浏览器在加载资源时，会先根据本地缓存资源的 header 中的信息判断是否命中强缓存，如果命中则直接使用缓存中的资源不会再向服务器发送请求。
​
这里的 header 中的信息指的是 expires 和 cahe-control.
​
Expires
该字段是 http1.0 时的规范，它的值为一个绝对时间的 GMT 格式的时间字符串，比如 Expires:Mon,18 Oct 2066 23:59:59 GMT。这个时间代表着这个资源的失效时间，在此时间之前，即命中缓存。这种方式有一个明显的缺点，由于失效时间是一个绝对时间，所以当服务器与客户端时间偏差较大时，就会导致缓存混乱（本地时间也可以随便更改）。
​
Cache-Control（优先级高于 Expires）
Cache-Control 是 http1.1 时出现的 header 信息，主要是利用该字段的 max-age 值来进行判断，它是一个相对时间，例如 Cache-Control:max-age=3600，代表着资源的有效期是 3600 秒。cache-control 除了该字段外，还有下面几个比较常用的设置值：
​
no-cache：需要进行协商缓存，发送请求到服务器确认是否使用缓存。
no-store：禁止使用缓存，每一次都要重新请求数据。
public：可以被所有的用户缓存，包括终端用户和 CDN 等中间代理服务器。
private：只能被终端用户的浏览器缓存，不允许 CDN 等中继缓存服务器对其缓存。
Cache-Control 与 Expires 可以在服务端配置同时启用，同时启用的时候 Cache-Control 优先级高。

### 什么是协商缓存

当强缓存没有命中的时候，浏览器会发送一个请求到服务器，服务器根据 header 中的部分信息来判断是否命中缓存。如果命中，则返回 304 ，告诉浏览器资源未更新，可使用本地的缓存。
​
这里的 header 中的信息指的是 Last-Modify/If-Modify-Since 和 ETag/If-None-Match.
​
Last-Modify/If-Modify-Since
浏览器第一次请求一个资源的时候，服务器返回的 header 中会加上 Last-Modify，Last-modify 是一个时间标识该资源的最后修改时间（只能精确到秒，所以间隔时间小于 1 秒的请求是检测不到文件更改的。）。
​
当浏览器再次请求该资源时，request 的请求头中会包含 If-Modify-Since，该值为缓存之前返回的 Last-Modify。服务器收到 If-Modify-Since 后，根据资源的最后修改时间判断是否命中缓存。
​
如果命中缓存，则返回 304，并且不会返回资源内容，并且不会返回 Last-Modify。
​
缺点:
​
短时间内资源发生了改变，Last-Modified 并不会发生变化。
​
周期性变化。如果这个资源在一个周期内修改回原来的样子了，我们认为是可以使用缓存的，但是 Last-Modified 可不这样认为, 因此便有了 ETag。
​
ETag/If-None-Match
Etag 是基于文件内容进行编码的，可以保证如果服务器有更新，一定会重新请求资源，但是编码需要付出额外的开销。
​
与 Last-Modify/If-Modify-Since 不同的是，Etag/If-None-Match 返回的是一个校验码。ETag 可以保证每一个资源是唯一的，资源变化都会导致 ETag 变化。服务器根据浏览器上送的 If-None-Match 值来判断是否命中缓存。
​
与 Last-Modified 不一样的是，当服务器返回 304 Not Modified 的响应时，由于 ETag 重新生成过，response header 中还会把这个 ETag 返回，即使这个 ETag 跟之前的没有变化。
​
Last-Modified 与 ETag 是可以一起使用的，服务器会优先验证 ETag，一致的情况下，才会继续比对 Last-Modified，最后才决定是否返回 304。

## 其他

### 跨域的概念和解决方法

#### 跨域的解决方法有哪些？

#### JSONP的原理？

#### CORS怎么使用？

#### Nginx如何设置？

### 从浏览器地址栏输入 url 到请求返回发生了什么

先阅读这篇科普性质的：[从 URL 输入到页面展现到底发生什么？](https://juejin.cn/post/6844903784229896199) 先阅读篇文章：[从输入 URL 开始建立前端知识体系](https://juejin.cn/post/6935232082482298911)。

1. 输入 URL 后解析出协议、主机、端口、路径等信息，并构造一个 HTTP 请求。

+ 强缓存。
+ 协商缓存。

2. DNS 域名解析。（[字节面试被虐后，是时候搞懂 DNS 了](https://juejin.cn/post/6990344840181940261)）

3. TCP 连接。总是要问：为什么需要三次握手，两次不行吗？其实这是由 TCP 的自身特点**可靠传输**决定的。客户端和服务端要进行可靠传输，那么就需要**确认双方的接收和发送能力**。第一次握手可以确认客服端的**发送能力**，第二次握手，确认了服务端的**发送能力和接收能力**，所以第三次握手才可以确认客户端的**接收能力**。不然容易出现丢包的现象。

4. http 请求。

5. 服务器处理请求并返回 HTTP 报文。

6. 浏览器渲染页面。

7. 断开 TCP 连接。

> 参考链接 :
>> [掘金 -- 做了一份前端面试复习计划，保熟～ -- vortesnail](https://juejin.cn/post/7061588533214969892)
