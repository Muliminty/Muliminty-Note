[å‚è€ƒæ–‡æ¡£](../../è½®å­/è½®å­-æ‹–æ‹½-dnd%20kitä½¿ç”¨æŒ‡å—/å‚è€ƒæ–‡æ¡£.md)
ç»„ä»¶æºç 
```jsx
import React from 'react';
import {
  DndContext, // DndKitçš„æ ¸å¿ƒç»„ä»¶ï¼Œç”¨äºå¤„ç†æ‹–æ‹½å’Œæ’åºçš„ä¸Šä¸‹æ–‡
  closestCenter, // ç”¨äºæ£€æµ‹æœ€æ¥è¿‘çš„ä½ç½®
  KeyboardSensor, // ç”¨äºå¤„ç†é”®ç›˜æ‹–æ‹½
  useSensor, // è‡ªå®šä¹‰Hookï¼Œç”¨äºä½¿ç”¨ä¼ æ„Ÿå™¨
  useSensors, // è‡ªå®šä¹‰Hookï¼Œç”¨äºä½¿ç”¨å¤šä¸ªä¼ æ„Ÿå™¨
  MouseSensor, // ç”¨äºå¤„ç†é¼ æ ‡æ‹–æ‹½
} from '@dnd-kit/core';
import {
  arrayMove, // ç”¨äºç§»åŠ¨æ•°ç»„ä¸­çš„å…ƒç´ ä½ç½®
  SortableContext, // ç”¨äºåˆ›å»ºå¯æ’åºçš„ä¸Šä¸‹æ–‡
  sortableKeyboardCoordinates, // ç”¨äºå¤„ç†å¯æ’åºå…ƒç´ çš„é”®ç›˜åæ ‡
  useSortable, // è‡ªå®šä¹‰Hookï¼Œç”¨äºå®ç°å¯æ’åºå…ƒç´ çš„è¡Œä¸º
} from '@dnd-kit/sortable';
import { CSS } from '@dnd-kit/utilities';

// SortListDndKitç»„ä»¶
const SortListDndKit = ({
  list = [],
  idKey = 'id',
  children,
  onDragEnd,
}) => {
  // ä½¿ç”¨å¤šä¸ªä¼ æ„Ÿå™¨
  const sensors = useSensors(
    useSensor(MouseSensor), // ä½¿ç”¨é¼ æ ‡ä¼ æ„Ÿå™¨
    useSensor(KeyboardSensor, {
      coordinateGetter: sortableKeyboardCoordinates, // ä½¿ç”¨é”®ç›˜ä¼ æ„Ÿå™¨ï¼Œå¹¶æŒ‡å®šé”®ç›˜åæ ‡çš„è·å–æ–¹å¼
    }),
  );

  // æ‹–æ‹½ç»“æŸçš„å¤„ç†å‡½æ•°
  const handleDragEnd = (event) => {
    const { active, over } = event; // è·å–æ‹–æ‹½äº‹ä»¶å¯¹è±¡ä¸­çš„activeå’Œoverå±æ€§
    if (active.id !== over.id) { // å¦‚æœæ‹–æ‹½çš„å…ƒç´ å’Œç›®æ ‡å…ƒç´ ä¸æ˜¯åŒä¸€ä¸ª
      const oldIndex = list.findIndex((item) => item[idKey] === active.id); // æ‰¾åˆ°æ‹–æ‹½å…ƒç´ åœ¨åˆ—è¡¨ä¸­çš„ç´¢å¼•
      const newIndex = list.findIndex((item) => item[idKey] === over.id); // æ‰¾åˆ°ç›®æ ‡å…ƒç´ åœ¨åˆ—è¡¨ä¸­çš„ç´¢å¼•
      const ids = list.map((item) => item[idKey]); // è·å–åˆ—è¡¨ä¸­æ‰€æœ‰å…ƒç´ çš„id
      [ids[newIndex], ids[oldIndex]] = [ids[oldIndex], ids[newIndex]]; // äº¤æ¢ç›®æ ‡å…ƒç´ å’Œæ‹–æ‹½å…ƒç´ çš„idä½ç½®
      const _val = arrayMove(list, oldIndex, newIndex); // æ ¹æ®ç´¢å¼•äº¤æ¢åˆ—è¡¨ä¸­å…ƒç´ çš„ä½ç½®
      onDragEnd(_val, ids); // è°ƒç”¨ä¼ å…¥çš„onDragEndå›è°ƒå‡½æ•°ï¼Œå¹¶ä¼ é€’æ›´æ–°åçš„åˆ—è¡¨å’Œidæ•°ç»„
    }
  };

  return (
    <DndContext
      sensors={sensors} // ä¼ é€’ä¼ æ„Ÿå™¨ç»™DndContext
      collisionDetection={closestCenter} // è®¾ç½®ç¢°æ’æ£€æµ‹å™¨ä¸ºclosestCenter
      onDragEnd={handleDragEnd} // è®¾ç½®æ‹–æ‹½ç»“æŸçš„å¤„ç†å‡½æ•°
    >
      <SortableContext items={list.map((item) => item[idKey])}>
        {children}
      </SortableContext>
    </DndContext>
  );
};

// SortItemDndKitç»„ä»¶
const SortItemDndKit = ({ id, children, handle = false, handleNode, ...props }) => {
  const { attributes, listeners, setNodeRef, transform, transition, isDragging } = useSortable({ id }); // ä½¿ç”¨useSortableè‡ªå®šä¹‰Hookï¼Œè·å–å¯æ’åºå…ƒç´ çš„å±æ€§å’Œè¡Œä¸º

  const style = {
    transform: CSS.Transform.toString(transform), // å°†transformå±æ€§è½¬æ¢ä¸ºå­—ç¬¦ä¸²
    transition,
    ...(isDragging ? { boxShadow: '0 4px 8px rgba(0, 0, 0, 0.2)', zIndex: 1000, position: 'relative' } : {}),
  };

  const newChild = React.Children.map(children, (child) => {
    if (!React.isValidElement(child)) {
      return null;
    }
    const childProps = {
      ...child.props,
      ref: setNodeRef, // å°†å…ƒç´ çš„å¼•ç”¨è®¾ç½®ä¸ºsetNodeRef
      ...(handle ? {} : attributes),
      ...(handle ? {} : listeners),
    };
    return React.cloneElement(child, childProps); // å…‹éš†å­å…ƒç´ ï¼Œå¹¶ä¼ é€’å±æ€§å’Œäº‹ä»¶ç›‘å¬å™¨
  });

  if (handle) {
    return <div {...props} style={{ ...style }}>
      <div className='handleNode' {...listeners} style={{ cursor: 'pointer' }} >{handleNode || '+'}</div>
      <div>{newChild}</div>
    </div >
  }
  if (!handle) {
    return <div style={{ ...style, cursor: 'pointer' }}>
      {newChild}
    </div>
  }
};


export { SortListDndKit, SortItemDndKit };



// ä½¿ç”¨æ–¹æ³•ï¼š
// 1. å¯¼å…¥SortListDndKitå’ŒSortItemDndKitç»„ä»¶ã€‚
// 2. åœ¨éœ€è¦æ‹–æ‹½å’Œæ’åºçš„åˆ—è¡¨çš„çˆ¶ç»„ä»¶ä¸­ä½¿ç”¨SortListDndKitç»„ä»¶ä½œä¸ºå®¹å™¨ç»„ä»¶ã€‚
// 3. åœ¨SortListDndKitç»„ä»¶å†…éƒ¨ï¼Œå°†åˆ—è¡¨æ•°æ®ä¼ é€’ç»™listå±æ€§ï¼Œåˆ—è¡¨é¡¹çš„å”¯ä¸€æ ‡è¯†ç¬¦ä¼ é€’ç»™idKeyå±æ€§ï¼Œä»¥åŠåœ¨æ‹–æ‹½ç»“æŸæ—¶è§¦å‘çš„å›è°ƒå‡½æ•°ä¼ é€’ç»™onDragEndå±æ€§ã€‚
// 4. ä½¿ç”¨SortItemDndKitç»„ä»¶ä½œä¸ºåˆ—è¡¨é¡¹çš„åŒ…è£…ç»„ä»¶ï¼Œå¹¶å°†æ¯ä¸ªåˆ—è¡¨é¡¹çš„å”¯ä¸€æ ‡è¯†ç¬¦ä¼ é€’ç»™idå±æ€§ã€‚
// 5. åœ¨SortItemDndKitç»„ä»¶å†…éƒ¨ï¼Œå°†è¦æ’åºçš„å†…å®¹ä½œä¸ºå­å…ƒç´ ä¼ é€’ã€‚
// 6. åœ¨onDragEndå›è°ƒå‡½æ•°ä¸­ï¼Œå¯ä»¥è·å–æ’åºåçš„åˆ—è¡¨æ•°æ®å’Œidæ•°ç»„ï¼Œå¹¶è¿›è¡Œè¿›ä¸€æ­¥çš„å¤„ç†ã€‚

```

ä½¿ç”¨æ–¹æ³•
```jsx
import React, { useState } from 'react'
import InnerTopBar from "@/components/Layouts/InnerTopBar";
import { Button } from "antd";
import { SortListDndKit, SortItemDndKit } from './Sortable';

export default function RroupedSorting() {
  const [list, setList] = useState([
    { id: "1", text: "Item 1" },
    { id: "2", text: "Item 2" },
    { id: "3", text: "Item 3" }
  ]);

  const handleDragEnd = (sortedList, sortedIds) => {
    console.log("Sorted List:", sortedList);
    console.log("Sorted Ids:", sortedIds);

    // æ›´æ–°åˆ—è¡¨æ•°æ®ä¸ºæ’åºåçš„é¡ºåº
    setList(sortedList);
  };
  return (
    <div>

      <InnerTopBar
        leftTitle="è¿”å›"
        returnPath="/flow/flowForm"
        rightTool={[<Button>ä¿å­˜</Button>]}
      />

      <SortListDndKit list={list} onDragEnd={handleDragEnd}>
        {list.map((item) => (
          <SortItemDndKit
            key={item.id}
            id={item.id}
            handle={true}
            handleNode={'ğŸ¤š'}
            className='SortItemDndKit'
          >
            <div>{item.text}</div>
          </SortItemDndKit>
        ))}
      </SortListDndKit>

    </div>
  )
}

```