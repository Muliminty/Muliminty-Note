核心在于“词法”一词的含义：它指的是在代码书写阶段（即词法分析阶段）就确定下来的作用域，而不是运行时确定的。

词法作用域（Lexical Scope）与词法（Lexical）的关联在于其**核心特征——由代码的书写位置决定作用域关系**，这正是"词法"一词的本质含义。以下是详细解析：

### 核心关联图示
```
词法分析阶段 → 确定作用域嵌套关系 → 形成词法作用域
      ↑                  ↑
    (词法)          (作用域规则)
```

### 具体关联点
1. **定义阶段的静态绑定**
   - **词法特性**：在词法分析阶段（代码书写时）确定标识符的绑定关系
   - **作用域表现**：函数/变量在**代码中的物理位置**决定其作用域链
   ```javascript
   function outer() {
     const x = 10; // 词法分析时确定作用域位置
     function inner() {
       console.log(x); // 静态绑定到outer的x
     }
     return inner;
   }
   ```

2. **环境记录的词法结构**
   - 词法作用域通过**词法环境（Lexical Environment）** 实现：
     ```mermaid
     graph LR
     A[inner词法环境] --> B[outer词法环境]
     B --> C[全局词法环境]
     ```
   - 每个环境记录包含：
     - **环境记录器**：存储当前作用域的变量
     - **外部引用**：指向**词法层面**的父级作用域

3. **与动态作用域的本质区别**
   | 特性         | 词法作用域                 | 动态作用域          |
   |--------------|---------------------------|-------------------|
   | **确定时机** | 词法分析阶段（编译时）     | 函数调用时（运行时）|
   | **依据**     | 代码物理结构               | 调用栈位置        |
   | **关联点**   | 直接对应"词法"的静态特性   | 无词法关联        |

4. **闭包机制的词法基础**
   - 闭包本质是**词法作用域的运行时表现**
   ```javascript
   function createCounter() {
     let count = 0; // 词法分析时被标识为闭包变量
     return function() {
       return count++; // 访问词法父级的变量
     };
   }
   // count的捕获发生在词法分析阶段
   ```

### 关键结论
- **词法决定作用域**：作用域链完全由代码的**词法结构**（函数/块的嵌套位置）决定
- **静态可分析**：在词法分析阶段即可确定所有标识符的绑定关系
- **不受运行时影响**：与调用栈无关，即使跨模块调用也保持原始作用域链

> 正是这种**由词法结构（源代码书写方式）静态决定作用域**的特性，使其被命名为"词法作用域"（Lexical Scope）。这区别于动态作用域（Dynamic Scope）的运行时绑定机制，体现了编译原理中词法分析阶段对程序结构的决定性影响。

