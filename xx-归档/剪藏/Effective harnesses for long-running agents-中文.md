[Effective harnesses for long-running agents \\ Anthropic](https://www.anthropic.com/engineering/effective-harnesses-for-long-running-agents)

# 长效运行智能体的有效约束机制

随着 AI 智能体能力增强，开发者越来越多地让它们承担需要数小时甚至数天才能完成的复杂任务。然而，让智能体在多个上下文窗口之间保持稳定、一致的进展，仍是一个尚未解决的问题。

长效运行智能体的核心难点在于：它们必须在离散的会话中工作，而每一次新会话开始时都没有对过往经历的记忆。可以想象一个由轮班工程师协作的软件项目——每位新到岗的工程师对上一班发生的事一无所知。由于上下文窗口有限，且大多数复杂项目无法在单次窗口内完成，智能体需要一种在多次编码会话之间「接棒」的机制。

我们设计了一套双轨方案，使 [Claude Agent SDK](https://platform.claude.com/docs/en/agent-sdk/overview) 能够在多个上下文窗口下有效工作：**初始化智能体**在首次运行时搭建环境，**编码智能体**则在每次会话中负责取得增量进展，并为下一轮会话留下清晰的可追溯产物。你可以在配套的 [quickstart](https://github.com/anthropics/claude-quickstarts/tree/main/autonomous-coding) 中找到代码示例。

## 长效运行智能体所面临的问题

Claude Agent SDK 是一个强大的通用智能体框架，擅长编码以及需要模型使用工具收集上下文、规划与执行的其他任务。它具备上下文管理能力（例如压缩），使智能体能在不耗尽上下文窗口的情况下持续工作。理论上，在这种设定下，智能体应能无限长时间地持续产出有效工作。

然而，仅靠压缩并不足够。开箱即用的情况下，即使用 Opus 4.5 这样的前沿编码模型，在 Claude Agent SDK 上跨多个上下文窗口循环运行，若只给出高层级提示（例如「构建一个 [claude.ai](http://claude.ai/redirect/website.v1.9c36c1d5-811b-4eb8-a91f-414f892fa05a) 的克隆」），也难以真正做出生产级质量的 Web 应用。

Claude 的失败主要表现为两种模式。其一，智能体倾向于一次做太多事——本质上是在尝试「一枪搞定」整个应用。这常常导致模型在实现中途耗尽上下文，下一轮会话不得不从一项只做了一半、且缺乏文档说明的功能接手。智能体只能猜测之前发生了什么，并花大量时间试图让基础应用重新跑起来。即便有压缩机制，这类情况仍会发生，因为压缩并不总能向下一轮智能体传递足够清晰的信息。

第二种失败模式往往在项目后期出现：在已有若干功能被实现后，后续某次智能体实例会环顾四周、看到已有进展，然后直接宣布任务完成。

由此可将问题拆成两部分：第一，需要搭建一个初始环境，为给定提示所要求的**所有**功能打好基础，使智能体能够按步骤、按功能逐步推进；第二，应引导每一轮智能体在朝目标取得**增量进展**的同时，在会话结束时把环境维持在「干净状态」。所谓干净状态，指的是适合合并到主分支的代码：没有严重缺陷、结构清晰且有文档，新来的开发者可以轻松在此基础上开发新功能，而不必先收拾无关的烂摊子。

在内部实验中，我们通过一套双轨方案应对上述问题：

1. **初始化智能体**：第一次智能体会话使用专门提示，要求模型搭建初始环境：包括 `init.sh` 脚本、记录各轮智能体所做工作的 `claude-progress.txt` 文件，以及一次标明新增文件的初始 git 提交。
2. **编码智能体**：之后的每次会话都要求模型取得增量进展，并留下结构化的更新记录。¹

关键洞察在于：要为智能体找到一种在全新上下文窗口下快速理解当前工作状态的方式，这通过 `claude-progress.txt` 与 git 历史共同实现。这些做法的灵感来自高效软件工程师的日常实践。

## 环境管理

在更新版 [Claude 4 提示指南](https://docs.claude.com/en/docs/build-with-claude/prompt-engineering/claude-4-best-practices#multi-context-window-workflows) 中，我们分享了多上下文窗口工作流的一些最佳实践，其中包括一种「在第一个上下文窗口使用不同提示」的约束结构。这一「不同提示」会要求初始化智能体搭建好环境，并准备好后续编码智能体有效工作所需的全部上下文。下面我们深入介绍这类环境中的几个关键组成部分。

### 功能列表

为解决智能体「一枪做完应用」或过早认为项目已完工的问题，我们让初始化智能体根据用户初始提示，编写一份详尽的功能需求文件。在 [claude.ai](http://claude.ai/redirect/website.v1.9c36c1d5-811b-4eb8-a91f-414f892fa05a) 克隆示例中，这意味着超过 200 项功能，例如「用户可打开新对话、输入问题、按回车并看到 AI 回复」。这些功能最初均标记为「未通过」，以便后续编码智能体对完整功能形态有清晰轮廓。

```json
{
    "category": "functional",
    "description": "New chat button creates a fresh conversation",
    "steps": [
      "Navigate to main interface",
      "Click the 'New Chat' button",
      "Verify a new conversation is created",
      "Check that chat area shows welcome state",
      "Verify conversation appears in sidebar"
    ],
    "passes": false
}
```

（示例：新建对话按钮创建全新会话；步骤含：进入主界面、点击「New Chat」、验证新对话被创建、检查对话区为欢迎状态、验证对话出现在侧栏。`passes` 为 false。）

我们要求编码智能体只通过修改 `passes` 字段来编辑该文件，并采用强硬措辞，例如「不得删除或修改测试，否则可能导致功能缺失或存在缺陷」。经过试验，我们最终采用 JSON 格式，因为与 Markdown 相比，模型更不容易对 JSON 进行不当修改或覆盖。

### 增量进展

在有了上述初始环境脚手架之后，编码智能体的每一轮迭代被要求**每次只做一项功能**。这种增量策略对遏制智能体「一次做太多」的倾向至关重要。

在按增量方式工作后，模型在完成代码修改后仍须将环境维持在干净状态。实验中我们发现，最有效的做法是要求模型：用清晰的 commit 信息将进展提交到 git，并在进度文件中写下进展摘要。这样模型可以利用 git 回滚错误修改、恢复代码库的可工作状态。

这些做法也提升了效率，因为智能体不再需要猜测之前发生了什么，也不必花时间重新把基础应用跑通。

### 测试

我们观察到的另一个主要失败模式是：Claude 倾向于在未充分测试的情况下就把功能标为完成。在没有明确提示时，Claude 会改代码，甚至用单元测试或对开发服务器的 `curl` 请求做测试，却往往无法意识到功能在端到端上并不成立。

在构建 Web 应用时，一旦我们明确要求使用浏览器自动化工具、并以真实用户的方式做全部测试，Claude 在端到端验证功能方面大多表现良好。

![Claude 通过 Puppeteer MCP 服务器测试 claude.ai 克隆时截取的截图。](https://www.anthropic.com/_next/image?url=https%3A%2F%2Fwww-cdn.anthropic.com%2Fimages%2F4zrzovbb%2Fwebsite%2Ff94c2257964fb2d623f1e81f874977ebfc0986bc-1920x1080.gif&w=3840&q=75)

*Claude 通过 Puppeteer MCP 服务器测试 claude.ai 克隆时截取的截图。*

为 Claude 提供这类测试工具显著提升了表现，因为智能体能够发现并修复仅从代码难以看出的问题。

仍存在一些局限，例如 Claude 的视觉能力与浏览器自动化工具的限制，使得某些类型的缺陷难以被识别。例如，通过 Puppeteer MCP 无法看到浏览器原生 alert 弹窗，依赖这类弹窗的功能因此更容易出问题。

## 快速进入状态

在上述机制就位后，每一轮编码智能体都会被要求按固定步骤「摸清情况」，有些步骤很基础但很有用：

1. _运行 `pwd` 确认当前工作目录，你只能在该目录下编辑文件。_
2. _阅读 git 日志与进度文件，了解最近完成了哪些工作。_
3. _阅读功能列表文件，选出一个尚未完成的、优先级最高的功能着手。_

这种做法在每个会话中为 Claude 节省了 token，因为它不必再自行摸索如何跑通和测试代码。同时，让初始化智能体编写能启动开发服务器的 `init.sh`，并在实现新功能前先跑一遍基础端到端测试，也很有帮助。

在 claude.ai 克隆的案例中，这意味着智能体总是先启动本地开发服务器，用 Puppeteer MCP 发起新对话、发送消息并接收回复，从而快速判断应用是否被留在损坏状态，并立刻修复既有问题。若智能体直接开始实现新功能，很可能让问题雪上加霜。

综合以上，一轮典型会话会以类似如下的助手消息开场：

```
[助手] 我先确认当前状态，了解项目进展。
[工具调用] <bash - pwd>
[工具调用] <读取 - claude-progress.txt>
[工具调用] <读取 - feature_list.json>
[助手] 查看 git 日志以了解近期工作。
[工具调用] <bash - git log --oneline -20>
[助手] 检查是否有 init.sh 用于重启服务。
<启动开发服务器>
[助手] 现在打开应用并验证一些基础功能是否仍正常。
<测试基础功能>
[助手] 根据验证测试，基础功能运行良好。核心对话、主题切换、对话加载与错误处理均正常。接下来全面查看 tests.json，确定下一步要实现的内容。
<开始实现新功能>
```

## 智能体失败模式与应对

| **问题** | **初始化智能体行为** | **编码智能体行为** |
|----------|----------------------|--------------------|
| Claude 过早宣布整个项目完成。 | 建立功能列表文件：根据输入规格，生成结构化 JSON，列出端到端功能描述。 | 在会话开始时读取功能列表，每次只选一个功能着手。 |
| Claude 留下带缺陷或未记录进展的环境。 | 建立初始 git 仓库并编写进度说明文件。 | 会话开始时读取进度文件与 git 提交记录，在开发服务器上跑基础测试以发现未记录的缺陷；会话结束时提交 git 并更新进度。 |
| Claude 过早将功能标为完成。 | 建立功能列表文件。 | 对功能进行自检；仅在仔细测试后才将功能标为「通过」。 |
| Claude 需要花时间摸索如何运行应用。 | 编写可启动开发服务器的 `init.sh`。 | 会话开始时阅读 `init.sh`。 |

*以上概括了长效运行 AI 智能体中四种常见失败模式及对应解法。*

## 后续工作

本研究展示了长效运行智能体约束机制中的一套可行方案，使模型能在多个上下文窗口间取得增量进展。但仍有开放问题。

尤其尚未明确的是：单一通用编码智能体是否在跨上下文中表现最佳，还是通过多智能体架构能获得更好表现。专门负责测试、质量保证或代码整理的智能体，在软件开发生命周期的子任务上很可能表现更优。

此外，当前演示针对全栈 Web 应用开发做了优化。未来方向之一是将这些发现推广到其他领域。这些经验中的部分或全部，很可能适用于科学研究、金融建模等场景下的长效运行智能体任务。

### 致谢

作者：Justin Young。特别感谢 David Hershey、Prithvi Rajasakeran、Jeremy Hadfield、Naia Bouscal、Michael Tingley、Jesse Mu、Jake Eaton、Marius Buleandara、Maggie Vo、Pedram Navid、Nadine Yasser、Alex Notov 的贡献。

本工作凝聚了 Anthropic 多个团队的共同努力，使 Claude 能够安全地进行长周期自主软件工程，尤其是 code RL 与 Claude Code 团队。欢迎有意加入的候选人在 [anthropic.com/careers](http://anthropic.com/careers) 申请。

### 脚注

¹ 我们在文中将其称为「不同智能体」，仅因它们的初始用户提示不同。系统提示、工具集与整体智能体约束机制在其他方面是一致的。
