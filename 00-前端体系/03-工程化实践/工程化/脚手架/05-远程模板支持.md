# è¿œç¨‹æ¨¡æ¿æ”¯æŒ

> æ”¯æŒä»è¿œç¨‹ä»“åº“ï¼ˆGitHubã€npmã€zip åŒ…ç­‰ï¼‰ä¸‹è½½æ¨¡æ¿ï¼Œå®ç°æ¨¡æ¿çš„å…±äº«å’Œå¤ç”¨ï¼ŒåŒ…æ‹¬æ¨¡æ¿ä¸‹è½½ã€ç¼“å­˜æœºåˆ¶ã€æ›´æ–°æ£€æŸ¥ç­‰åŠŸèƒ½ã€‚

---

## ğŸ“‹ ç›®å½•

- [1. GitHub ä»“åº“æ¨¡æ¿ä¸‹è½½](#1-github-ä»“åº“æ¨¡æ¿ä¸‹è½½)
- [2. npm åŒ…æ¨¡æ¿æ”¯æŒ](#2-npm-åŒ…æ¨¡æ¿æ”¯æŒ)
- [3. zip åŒ…æ¨¡æ¿å¤„ç†](#3-zip-åŒ…æ¨¡æ¿å¤„ç†)
- [4. æ¨¡æ¿ç¼“å­˜æœºåˆ¶](#4-æ¨¡æ¿ç¼“å­˜æœºåˆ¶)
- [5. æ¨¡æ¿æ›´æ–°æ£€æŸ¥](#5-æ¨¡æ¿æ›´æ–°æ£€æŸ¥)

---

## 1. GitHub ä»“åº“æ¨¡æ¿ä¸‹è½½

### 1.1 ä½¿ç”¨ GitHub API

```typescript
// src/utils/github.ts
import https from 'https';
import { execSync } from 'child_process';
import path from 'path';
import fs from 'fs-extra';

export interface GitHubTemplate {
  owner: string;
  repo: string;
  branch?: string;
  path?: string; // å­ç›®å½•è·¯å¾„
}

export async function downloadFromGitHub(
  template: GitHubTemplate,
  targetDir: string
): Promise<void> {
  const { owner, repo, branch = 'main', path: subPath } = template;
  
  // ä½¿ç”¨ git clone ä¸‹è½½ï¼ˆæ¨èæ–¹å¼ï¼‰
  const repoUrl = `https://github.com/${owner}/${repo}.git`;
  const tempDir = path.join(process.cwd(), '.temp', `${owner}-${repo}`);
  
  try {
    // æ¸…ç†ä¸´æ—¶ç›®å½•
    if (await fs.pathExists(tempDir)) {
      await fs.remove(tempDir);
    }

    // Clone ä»“åº“
    execSync(`git clone --depth 1 --branch ${branch} ${repoUrl} ${tempDir}`, {
      stdio: 'inherit'
    });

    // å¦‚æœæŒ‡å®šäº†å­è·¯å¾„ï¼Œåªå¤åˆ¶å­è·¯å¾„å†…å®¹
    const sourcePath = subPath
      ? path.join(tempDir, subPath)
      : tempDir;

    if (!(await fs.pathExists(sourcePath))) {
      throw new Error(`Template path not found: ${subPath}`);
    }

    // å¤åˆ¶åˆ°ç›®æ ‡ç›®å½•
    await fs.copy(sourcePath, targetDir, {
      filter: (src) => {
        // æ’é™¤ .git ç›®å½•
        return !src.includes('.git');
      }
    });

    // æ¸…ç†ä¸´æ—¶ç›®å½•
    await fs.remove(tempDir);
  } catch (error) {
    // ç¡®ä¿æ¸…ç†ä¸´æ—¶ç›®å½•
    if (await fs.pathExists(tempDir)) {
      await fs.remove(tempDir).catch(() => {});
    }
    throw error;
  }
}
```

### 1.2 ä½¿ç”¨ GitHub API ä¸‹è½½ï¼ˆå¤‡é€‰æ–¹æ¡ˆï¼‰

```typescript
// ä½¿ç”¨ GitHub API ä¸‹è½½ zip åŒ…
export async function downloadFromGitHubAPI(
  template: GitHubTemplate,
  targetDir: string
): Promise<void> {
  const { owner, repo, branch = 'main' } = template;
  const zipUrl = `https://api.github.com/repos/${owner}/${repo}/zipball/${branch}`;

  // ä¸‹è½½ zip æ–‡ä»¶
  const zipPath = path.join(process.cwd(), '.temp', `${owner}-${repo}.zip`);
  await fs.ensureDir(path.dirname(zipPath));

  await downloadFile(zipUrl, zipPath);

  // è§£å‹ zip æ–‡ä»¶
  await extractZip(zipPath, targetDir);

  // æ¸…ç†ä¸´æ—¶æ–‡ä»¶
  await fs.remove(zipPath);
}

async function downloadFile(url: string, dest: string): Promise<void> {
  return new Promise((resolve, reject) => {
    const file = fs.createWriteStream(dest);
    
    https.get(url, (response) => {
      if (response.statusCode === 302 || response.statusCode === 301) {
        // å¤„ç†é‡å®šå‘
        https.get(response.headers.location!, (redirectResponse) => {
          redirectResponse.pipe(file);
          file.on('finish', () => {
            file.close();
            resolve();
          });
        }).on('error', reject);
      } else {
        response.pipe(file);
        file.on('finish', () => {
          file.close();
          resolve();
        });
      }
    }).on('error', reject);
  });
}
```

### 1.3 ä½¿ç”¨ç¤ºä¾‹

```typescript
// ä½¿ç”¨ GitHub æ¨¡æ¿
await downloadFromGitHub(
  {
    owner: 'user',
    repo: 'my-template',
    branch: 'main',
    path: 'templates/react' // å¯é€‰ï¼šæŒ‡å®šå­ç›®å½•
  },
  './my-app'
);
```

---

## 2. npm åŒ…æ¨¡æ¿æ”¯æŒ

### 2.1 npm åŒ…æ¨¡æ¿ç»“æ„

```
my-template-package/
â”œâ”€â”€ package.json
â”œâ”€â”€ templates/
â”‚   â”œâ”€â”€ react/
â”‚   â”‚   â”œâ”€â”€ package.json.ejs
â”‚   â”‚   â””â”€â”€ src/
â”‚   â””â”€â”€ vue/
â”‚       â”œâ”€â”€ package.json.ejs
â”‚       â””â”€â”€ src/
â””â”€â”€ template.config.json
```

### 2.2 ä¸‹è½½ npm åŒ…æ¨¡æ¿

```typescript
// src/utils/npm.ts
import { execSync } from 'child_process';
import path from 'path';
import fs from 'fs-extra';

export async function downloadFromNpm(
  packageName: string,
  targetDir: string,
  templateName?: string
): Promise<void> {
  const tempDir = path.join(process.cwd(), '.temp', packageName);

  try {
    // æ¸…ç†ä¸´æ—¶ç›®å½•
    if (await fs.pathExists(tempDir)) {
      await fs.remove(tempDir);
    }
    await fs.ensureDir(tempDir);

    // å®‰è£… npm åŒ…åˆ°ä¸´æ—¶ç›®å½•
    execSync(`npm install ${packageName} --prefix ${tempDir}`, {
      stdio: 'inherit'
    });

    // æŸ¥æ‰¾æ¨¡æ¿ç›®å½•
    const packageDir = path.join(tempDir, 'node_modules', packageName);
    const templatesDir = path.join(packageDir, 'templates');

    if (!(await fs.pathExists(templatesDir))) {
      throw new Error(`Templates directory not found in ${packageName}`);
    }

    // å¦‚æœæŒ‡å®šäº†æ¨¡æ¿åï¼Œä½¿ç”¨æŒ‡å®šæ¨¡æ¿
    // å¦åˆ™ä½¿ç”¨é»˜è®¤æ¨¡æ¿æˆ–ç¬¬ä¸€ä¸ªæ¨¡æ¿
    let sourcePath: string;
    
    if (templateName) {
      sourcePath = path.join(templatesDir, templateName);
      if (!(await fs.pathExists(sourcePath))) {
        throw new Error(`Template ${templateName} not found`);
      }
    } else {
      // æŸ¥æ‰¾é»˜è®¤æ¨¡æ¿
      const configPath = path.join(packageDir, 'template.config.json');
      if (await fs.pathExists(configPath)) {
        const config = await fs.readJson(configPath);
        sourcePath = path.join(templatesDir, config.defaultTemplate || 'default');
      } else {
        // ä½¿ç”¨ç¬¬ä¸€ä¸ªæ¨¡æ¿
        const templates = await fs.readdir(templatesDir);
        sourcePath = path.join(templatesDir, templates[0]);
      }
    }

    // å¤åˆ¶æ¨¡æ¿åˆ°ç›®æ ‡ç›®å½•
    await fs.copy(sourcePath, targetDir, {
      filter: (src) => {
        // æ’é™¤ node_modules
        return !src.includes('node_modules');
      }
    });

    // æ¸…ç†ä¸´æ—¶ç›®å½•
    await fs.remove(tempDir);
  } catch (error) {
    // ç¡®ä¿æ¸…ç†ä¸´æ—¶ç›®å½•
    if (await fs.pathExists(tempDir)) {
      await fs.remove(tempDir).catch(() => {});
    }
    throw error;
  }
}
```

### 2.3 ä½¿ç”¨ç¤ºä¾‹

```typescript
// ä½¿ç”¨ npm åŒ…æ¨¡æ¿
await downloadFromNpm('my-template-package', './my-app', 'react');
```

---

## 3. zip åŒ…æ¨¡æ¿å¤„ç†

### 3.1 ä¸‹è½½å’Œè§£å‹ zip åŒ…

```typescript
// src/utils/zip.ts
import https from 'https';
import http from 'http';
import path from 'path';
import fs from 'fs-extra';
import { extract } from 'zip-lib'; // éœ€è¦å®‰è£… zip-lib æˆ–ä½¿ç”¨å…¶ä»–è§£å‹åº“

export async function downloadFromZip(
  zipUrl: string,
  targetDir: string
): Promise<void> {
  const zipPath = path.join(process.cwd(), '.temp', 'template.zip');

  try {
    // ä¸‹è½½ zip æ–‡ä»¶
    await downloadFile(zipUrl, zipPath);

    // è§£å‹ zip æ–‡ä»¶
    await extractZip(zipPath, targetDir);

    // æ¸…ç†ä¸´æ—¶æ–‡ä»¶
    await fs.remove(zipPath);
  } catch (error) {
    // ç¡®ä¿æ¸…ç†ä¸´æ—¶æ–‡ä»¶
    if (await fs.pathExists(zipPath)) {
      await fs.remove(zipPath).catch(() => {});
    }
    throw error;
  }
}

async function downloadFile(url: string, dest: string): Promise<void> {
  return new Promise((resolve, reject) => {
    const protocol = url.startsWith('https') ? https : http;
    const file = fs.createWriteStream(dest);

    protocol.get(url, (response) => {
      if (response.statusCode === 302 || response.statusCode === 301) {
        // å¤„ç†é‡å®šå‘
        const redirectUrl = response.headers.location!;
        const redirectProtocol = redirectUrl.startsWith('https') ? https : http;
        
        redirectProtocol.get(redirectUrl, (redirectResponse) => {
          redirectResponse.pipe(file);
          file.on('finish', () => {
            file.close();
            resolve();
          });
        }).on('error', reject);
      } else {
        response.pipe(file);
        file.on('finish', () => {
          file.close();
          resolve();
        });
      }
    }).on('error', reject);
  });
}

async function extractZip(zipPath: string, targetDir: string): Promise<void> {
  await fs.ensureDir(targetDir);
  await extract(zipPath, targetDir);
}
```

---

## 4. æ¨¡æ¿ç¼“å­˜æœºåˆ¶

### 4.1 ç¼“å­˜ç®¡ç†å™¨

```typescript
// src/utils/cache.ts
import path from 'path';
import fs from 'fs-extra';
import crypto from 'crypto';

export class TemplateCache {
  private cacheDir: string;

  constructor() {
    this.cacheDir = path.join(
      require('os').homedir(),
      '.my-cli',
      'cache',
      'templates'
    );
    this.ensureCacheDir();
  }

  private async ensureCacheDir(): Promise<void> {
    await fs.ensureDir(this.cacheDir);
  }

  // ç”Ÿæˆç¼“å­˜é”®
  private getCacheKey(source: string): string {
    return crypto.createHash('md5').update(source).digest('hex');
  }

  // è·å–ç¼“å­˜è·¯å¾„
  private getCachePath(cacheKey: string): string {
    return path.join(this.cacheDir, cacheKey);
  }

  // æ£€æŸ¥ç¼“å­˜æ˜¯å¦å­˜åœ¨
  async hasCache(source: string): Promise<boolean> {
    const cacheKey = this.getCacheKey(source);
    const cachePath = this.getCachePath(cacheKey);
    return await fs.pathExists(cachePath);
  }

  // è·å–ç¼“å­˜
  async getCache(source: string): Promise<string | null> {
    if (await this.hasCache(source)) {
      const cacheKey = this.getCacheKey(source);
      return this.getCachePath(cacheKey);
    }
    return null;
  }

  // è®¾ç½®ç¼“å­˜
  async setCache(source: string, templatePath: string): Promise<void> {
    const cacheKey = this.getCacheKey(source);
    const cachePath = this.getCachePath(cacheKey);

    // å¦‚æœç¼“å­˜å·²å­˜åœ¨ï¼Œå…ˆåˆ é™¤
    if (await fs.pathExists(cachePath)) {
      await fs.remove(cachePath);
    }

    // å¤åˆ¶åˆ°ç¼“å­˜ç›®å½•
    await fs.copy(templatePath, cachePath);
  }

  // æ¸…é™¤ç¼“å­˜
  async clearCache(source?: string): Promise<void> {
    if (source) {
      const cacheKey = this.getCacheKey(source);
      const cachePath = this.getCachePath(cacheKey);
      if (await fs.pathExists(cachePath)) {
        await fs.remove(cachePath);
      }
    } else {
      // æ¸…é™¤æ‰€æœ‰ç¼“å­˜
      await fs.remove(this.cacheDir);
      await this.ensureCacheDir();
    }
  }

  // è·å–ç¼“å­˜ä¿¡æ¯
  async getCacheInfo(): Promise<{ count: number; size: number }> {
    const entries = await fs.readdir(this.cacheDir);
    let totalSize = 0;

    for (const entry of entries) {
      const entryPath = path.join(this.cacheDir, entry);
      const stat = await fs.stat(entryPath);
      if (stat.isDirectory()) {
        totalSize += await this.getDirSize(entryPath);
      }
    }

    return {
      count: entries.length,
      size: totalSize
    };
  }

  private async getDirSize(dirPath: string): Promise<number> {
    let size = 0;
    const entries = await fs.readdir(dirPath);

    for (const entry of entries) {
      const entryPath = path.join(dirPath, entry);
      const stat = await fs.stat(entryPath);

      if (stat.isDirectory()) {
        size += await this.getDirSize(entryPath);
      } else {
        size += stat.size;
      }
    }

    return size;
  }
}
```

### 4.2 ä½¿ç”¨ç¼“å­˜

```typescript
// åœ¨ä¸‹è½½æ¨¡æ¿æ—¶ä½¿ç”¨ç¼“å­˜
const cache = new TemplateCache();
const cacheKey = `github:${owner}/${repo}:${branch}`;

// æ£€æŸ¥ç¼“å­˜
if (await cache.hasCache(cacheKey)) {
  const cachedPath = await cache.getCache(cacheKey);
  await fs.copy(cachedPath!, targetDir);
} else {
  // ä¸‹è½½æ¨¡æ¿
  const tempDir = path.join(process.cwd(), '.temp', 'template');
  await downloadFromGitHub(template, tempDir);
  
  // ä¿å­˜åˆ°ç¼“å­˜
  await cache.setCache(cacheKey, tempDir);
  
  // å¤åˆ¶åˆ°ç›®æ ‡ç›®å½•
  await fs.copy(tempDir, targetDir);
}
```

---

## 5. æ¨¡æ¿æ›´æ–°æ£€æŸ¥

### 5.1 æ£€æŸ¥æ¨¡æ¿æ›´æ–°

```typescript
// src/utils/update.ts
import { execSync } from 'child_process';
import path from 'path';
import fs from 'fs-extra';

export interface TemplateInfo {
  source: string;
  type: 'github' | 'npm' | 'zip';
  version?: string;
  lastUpdate?: Date;
}

export class TemplateUpdater {
  private cache: TemplateCache;

  constructor() {
    this.cache = new TemplateCache();
  }

  // æ£€æŸ¥ GitHub æ¨¡æ¿æ›´æ–°
  async checkGitHubUpdate(
    owner: string,
    repo: string,
    branch: string = 'main'
  ): Promise<boolean> {
    try {
      // è·å–æœ€æ–° commit SHA
      const apiUrl = `https://api.github.com/repos/${owner}/${repo}/commits/${branch}`;
      const response = await fetch(apiUrl);
      const data = await response.json();
      const latestSha = data.sha;

      // æ£€æŸ¥ç¼“å­˜çš„ SHA
      const cacheKey = `github:${owner}/${repo}:${branch}`;
      const cachePath = await this.cache.getCache(cacheKey);
      
      if (!cachePath) {
        return true; // æ²¡æœ‰ç¼“å­˜ï¼Œéœ€è¦ä¸‹è½½
      }

      // è¯»å–ç¼“å­˜çš„ SHAï¼ˆå¦‚æœå­˜åœ¨ï¼‰
      const shaPath = path.join(cachePath, '.template-sha');
      if (await fs.pathExists(shaPath)) {
        const cachedSha = await fs.readFile(shaPath, 'utf-8');
        return cachedSha !== latestSha;
      }

      return true; // æ²¡æœ‰ SHA è®°å½•ï¼Œéœ€è¦æ›´æ–°
    } catch (error) {
      console.warn('æ£€æŸ¥æ›´æ–°å¤±è´¥:', error);
      return false;
    }
  }

  // æ£€æŸ¥ npm åŒ…æ›´æ–°
  async checkNpmUpdate(packageName: string): Promise<boolean> {
    try {
      // è·å–æœ€æ–°ç‰ˆæœ¬
      const latestVersion = execSync(
        `npm view ${packageName} version`,
        { encoding: 'utf-8' }
      ).trim();

      // æ£€æŸ¥ç¼“å­˜çš„ç‰ˆæœ¬
      const cacheKey = `npm:${packageName}`;
      const cachePath = await this.cache.getCache(cacheKey);
      
      if (!cachePath) {
        return true; // æ²¡æœ‰ç¼“å­˜ï¼Œéœ€è¦ä¸‹è½½
      }

      // è¯»å–ç¼“å­˜çš„ç‰ˆæœ¬
      const versionPath = path.join(cachePath, '.template-version');
      if (await fs.pathExists(versionPath)) {
        const cachedVersion = await fs.readFile(versionPath, 'utf-8');
        return cachedVersion !== latestVersion;
      }

      return true; // æ²¡æœ‰ç‰ˆæœ¬è®°å½•ï¼Œéœ€è¦æ›´æ–°
    } catch (error) {
      console.warn('æ£€æŸ¥æ›´æ–°å¤±è´¥:', error);
      return false;
    }
  }

  // æ›´æ–°æ¨¡æ¿
  async updateTemplate(
    source: string,
    type: 'github' | 'npm' | 'zip'
  ): Promise<void> {
    const cacheKey = `${type}:${source}`;
    await this.cache.clearCache(cacheKey);
    
    // é‡æ–°ä¸‹è½½æ¨¡æ¿
    // è¿™é‡Œéœ€è¦æ ¹æ®ç±»å‹è°ƒç”¨ç›¸åº”çš„ä¸‹è½½å‡½æ•°
  }
}
```

### 5.2 ä½¿ç”¨æ›´æ–°æ£€æŸ¥

```typescript
// åœ¨åˆ›å»ºé¡¹ç›®æ—¶æ£€æŸ¥æ›´æ–°
const updater = new TemplateUpdater();

if (options.template.startsWith('github:')) {
  const [owner, repo, branch = 'main'] = options.template
    .replace('github:', '')
    .split('/');
  
  const needsUpdate = await updater.checkGitHubUpdate(owner, repo, branch);
  
  if (needsUpdate) {
    logger.info('å‘ç°æ¨¡æ¿æ›´æ–°ï¼Œæ­£åœ¨æ›´æ–°...');
    await updater.updateTemplate(`${owner}/${repo}`, 'github');
  }
}
```

---

## ğŸ“ æ€»ç»“

### æ ¸å¿ƒåŠŸèƒ½

1. âœ… GitHub ä»“åº“æ¨¡æ¿ä¸‹è½½
2. âœ… npm åŒ…æ¨¡æ¿æ”¯æŒ
3. âœ… zip åŒ…æ¨¡æ¿å¤„ç†
4. âœ… æ¨¡æ¿ç¼“å­˜æœºåˆ¶
5. âœ… æ¨¡æ¿æ›´æ–°æ£€æŸ¥

### ä¸‹ä¸€æ­¥

- [å‘å¸ƒä¸æ‰©å±•](./06-å‘å¸ƒä¸æ‰©å±•.md) - å‘å¸ƒè„šæ‰‹æ¶åˆ° npm å¹¶å®ç°æ‰©å±•èƒ½åŠ›

---

#è„šæ‰‹æ¶ #å‰ç«¯å·¥ç¨‹åŒ– #è¿œç¨‹æ¨¡æ¿ #GitHub #npm

