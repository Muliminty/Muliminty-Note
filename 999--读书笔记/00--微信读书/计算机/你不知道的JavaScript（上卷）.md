---
doc_type: weread-highlights-reviews
bookId: "22806945"
author: 凯尔辛普森
cover: https://wfqqreader-1252317822.image.myqcloud.com/cover/945/22806945/t7_22806945.jpg
reviewCount: 1
noteCount: 42
isbn: 9787115385734
category: 计算机-编程设计
lastReadDate: 2023-09-08
---
# 元数据
> [!abstract] 你不知道的JavaScript（上卷）
> - ![ 你不知道的JavaScript（上卷）|200](https://wfqqreader-1252317822.image.myqcloud.com/cover/945/22806945/t7_22806945.jpg)
> - 书名： 你不知道的JavaScript（上卷）
> - 作者： 凯尔辛普森
> - 简介： 很多人对JavaScript这门语言的印象都是简单易学，很容易上手。JavaScript语言本身有很多复杂的概念，语言的使用者不必深入理解这些概念也可以编写出功能全面的应用。殊不知，这些复杂精妙的概念才是语言的精髓，即使是经验丰富的JavaScript开发人员，如果没有认真学习的话也无法真正理解它们。在本书中，我们要直面当前JavaScript开发者不求甚解的大趋势，深入理解语言内部的机制。本书既适合JavaScript语言初学者阅读，又适合经验丰富的JavaScript开发人员深入学习。
> - 出版时间 2015-04-01 00:00:00
> - ISBN： 9787115385734
> - 分类： 计算机-编程设计
> - 出版社： 人民邮电出版社

# 高亮划线

## 1.1 编译原理


> 📌 编译 ^22806945-10-756-758
   - ⌚ 2023-09-08 11:36:45 
## 1.2 理解作用域


> 📌 但是引擎执行怎样的查找，会影响最终的查找结果 ^22806945-11-2310-2332
   - ⌚ 2022-10-10 13:57:53 

> 📌 赋值操作的左侧和右侧。 ^22806945-11-2525-2536
   - ⌚ 2022-10-10 13:58:26 

> 📌 而LHS查询则是试图找到变量的容器本身，从而可以对其赋值。 ^22806945-11-2672-2701
   - ⌚ 2022-10-10 14:02:22 

> 📌 你可以将RHS理解成retrieve his source value（取到它的源值），这意味着“得到某某的值”。 ^22806945-11-2799-2856
   - ⌚ 2022-10-10 14:02:05 

> 📌 因此在概念上最好将其理解为“赋值操作的目标是谁（LHS）”以及“谁是赋值操作的源头（RHS）”。 ^22806945-11-3452-3500
   - ⌚ 2022-10-10 14:03:07 

> 📌 编译器可以在代码生成的同时处理声明和值的定义，比如在引擎执行代码时，并不会有线程专门用来将一个函数值“分配给”foo。因此，将函数声明理解成前面讨论的LHS查询和赋值的形式并不合适。 ^22806945-11-4612-4703
   - ⌚ 2022-10-20 11:18:40 
## 1.3 作用域嵌套


> 📌 在当前作用域中无法找到某个变量时，引擎就会在外层嵌套的作用域中继续查找，直到找到该变量，或抵达最外层的作用域（也就是全局作用域）为止。 ^22806945-12-529-596
   - ⌚ 2022-10-22 10:53:15 
## 4.3 函数优先


> 📌 ．的声明之前，但它是重复的声明（因此被忽略了），因为函数声明会被提升到普通变量之前。尽管重复的var声明会被忽略掉，但出现在后面的函数声明还是可以覆盖前面的。foo(); // 3function foo() {console.log(1);}var foo = function() {console.log(2);}; ^22806945-28-1197
   - ⌚ 2022-11-13 11:22:02 
## 5.2 实质问题


> 📌 当函数可以记住并访问所在的词法作用域时，就产生了闭包，即使函数是在当前词法作用域之外执行。 ^22806945-32-525-570
   - ⌚ 2022-11-22 10:56:20 

> 📌 我认为最准确地用来解释bar()对a的引用的方法是词法作用域的查找规则，而这些规则只是闭包的一部分。（但却是非常重要的一部分！） ^22806945-32-1173-1293
   - ⌚ 2022-11-22 11:09:29 

> 📌 实际上只是通过不同的标识符引用调用了内部的函数bar() ^22806945-32-2289-2317
   - ⌚ 2022-11-22 11:14:07 

> 📌 闭包使得函数可以继续访问定义时的词法作用域 ^22806945-32-3029-3050
   - ⌚ 2022-11-22 11:16:45 
## 5.3 现在我懂了


> 📌 在定时器、事件监听器、Ajax请求、跨窗口通信、Web Workers或者任何其他的异步（或者同步）任务中，只要使用了回调函数，实际上就是在使用闭包！ ^22806945-33-1775-1878
   - ⌚ 2022-11-22 11:23:24 
## 5.5 模块


> 📌 5.5 模块还有其他的代码模式利用闭包的强大威力，但从表面上看，它们似乎与回调无关。下面一起来研究其中最强大的一个：模块。 ^22806945-35-383-502
   - ⌚ 2022-11-25 15:42:25 

> 📌 为我们自己着想，应该多花一点时间来研究这些示例代码并完全理解闭包的作用吧。 ^22806945-35-8070-8107
   - ⌚ 2022-11-25 15:17:31 
## 附录A 动态作用域


> 📌 词法作用域是一套关于引擎如何寻找变量以及会在何处找到变量的规则。词法作用域最重要的特征是它的定义过程发生在代码的书写阶段（假设你没有使用eval()或with）。 ^22806945-37-646-727
   - ⌚ 2022-11-28 09:05:03 

> 📌 动态作用域并不关心函数和作用域是如何声明以及在何处声明的，只关心它们从何处调用。换句话说，作用域链是基于调用栈的，而不是代码中的作用域嵌套。 ^22806945-37-1245-1343
   - ⌚ 2022-11-28 09:06:50 

> 📌 主要区别：词法作用域是在写代码或者说定义时确定的，而动态作用域是在运行时确定的。（this也是！）词法作用域关注函数在何处声明，而动态作用域关注函数从何处调用。 ^22806945-37-2242-2322
   - ⌚ 2022-11-28 09:13:08 
## 1.2 误解


> 📌 但是在第二个例子中，传入setTimeout(..)的回调函数没有名称标识符（这种函数被称为匿名函数），因此无法从函数内部引用自身。 ^22806945-45-3897-3963
   - ⌚ 2022-11-30 10:03:47 

> 📌 arguments.callee已经被弃用，不应该再使用它。 ^22806945-45-4252-4282
   - ⌚ 2022-11-30 10:05:08 

> 📌 每当你想要把this和词法作用域的查找混合使用时，一定要提醒自己，这是无法实现的。 ^22806945-45-6942-6983
   - ⌚ 2022-11-30 10:16:17 
## 1.3 this到底是什么


> 📌 当一个函数被调用时，会创建一个活动记录（有时候也称为执行上下文） ^22806945-46-602-634
   - ⌚ 2022-11-30 10:16:49 
## 2.5 this词法


> 📌 箭头函数的绑定无法被修改。（new也不行！） ^22806945-53-1302-1324
   - ⌚ 2022-12-02 11:25:10 
## 3.2 类型


> 📌 null有时会被当作一种对象类型，但是这其实只是语言本身的一个bug，即对null执行typeof null时会返回字符串"object"。[插图]实际上，null本身是基本类型。 ^22806945-57-872-1134
   - ⌚ 2022-12-02 14:15:52 

> 📌 原始值"I am a string"并不是一个对象，它只是一个字面量，并且是一个不可变的值。如果要在这个字面量上执行一些操作，比如获取长度、访问其中某个字符等，那需要将其转换为String对象。 ^22806945-57-2998-3095
   - ⌚ 2022-12-03 14:49:05 
## 3.3 内容


> 📌 .a语法通常被称为“属性访问”, ["a"]语法通常被称为“键访问”。 ^22806945-58-895-930
   - ⌚ 2022-12-03 14:57:08 
## 5.1 [[Prototype]]


> 📌 JavaScript中的对象有一个特殊的[[Prototype]]内置属性，其实就是对于其他对象的引用。几乎所有的对象在创建时[[Prototype]]属性都会被赋予一个非空的值。 ^22806945-68-427-517
   - ⌚ 2022-12-14 09:36:03 

> 📌 对于默认的[[Get]]操作来说，如果无法在对象本身找到需要的属性，就会继续访问对象的[[Prototype]]链： ^22806945-68-1269-1327
   - ⌚ 2022-12-13 20:14:51 
## 5.2 “类”


> 📌 调用new Foo()时会创建a（具体的4个步骤参见第2章），其中一步就是将a内部的[[Prototype]]链接到Foo.prototype所指向的对象。 ^22806945-69-1808-1886
   - ⌚ 2022-12-15 09:01:03 

> 📌 实际上，Foo和你程序中的其他函数没有任何区别。函数本身并不是构造函数，然而，当你在普通的函数调用前面加上new关键字之后，就会把这个函数调用变成一个“构造函数调用”。实际上，new会劫持所有普通函数并用构造对象的形式来调用它。 ^22806945-69-6288-6402
   - ⌚ 2022-12-16 09:14:11 

> 📌 换句话说，在JavaScript中对于“构造函数”最准确的解释是，所有带new的函数调用。函数不是构造函数，但是当且仅当使用new时，函数调用会变成“构造函数调用”。 ^22806945-69-6981-7093
   - ⌚ 2022-12-16 09:15:41 

> 📌 回顾“构造函数”之前讨论．constructor属性时我们说过，看起来a.constructor === Foo为真意味着a确实有一个指向Foo的．constructor属性，但是事实不是这样。这是一个很不幸的误解。实际上，.constructor引用同样被委托给了Foo.prototype，而Foo.prototype.constructor默认指向Foo。 ^22806945-69-8435-8675
   - ⌚ 2022-12-16 09:23:00 

> 📌 a1并没有．constructor属性，所以它会委托[[Prototype]]链上的Foo. prototype。但是这个对象也没有．constructor属性（不过默认的Foo.prototype对象有这个属性！），所以它会继续委托，这次会委托给委托链顶端的Object.prototype。这个对象有．constructor属性，指向内置的Object(..)函数。 ^22806945-69-9500-9713
   - ⌚ 2022-12-16 09:41:26 

> 📌 最好的办法是记住这一点“constructor并不表示被构造 ^22806945-69-10673-10703
   - ⌚ 2022-12-16 09:47:15 

> 📌 a1.constructor是一个非常不可靠并且不安全的引用。通常来说要尽量避免使用这些引用。 ^22806945-69-11214-11261
   - ⌚ 2022-12-16 09:50:00 
## 5.3 （原型）继承


> 📌 这段代码的核心部分就是语句Bar.prototype = Object.create(Foo.prototype)。调用Object.create(..)会凭空创建一个“新”对象并把新对象内部的[[Prototype]]关联到你指定的对象（本例中是Foo.prototype）。 ^22806945-70-2194-2333
   - ⌚ 2022-12-16 09:57:54 

> 📌 因此我们创建了一个新对象并把它关联到我们希望的对象上，直接把原始的关联对象抛弃掉 ^22806945-70-2564-2632
   - ⌚ 2022-12-16 10:01:13 

> 📌 因此，要创建一个合适的关联对象，我们必须使用Object.create(..)而不是使用具有副作用的Foo(..)。这样做唯一的缺点就是需要创建一个新对象然后把旧对象抛弃掉，不能直接修改已有的默认对象。 ^22806945-70-3296-3397
   - ⌚ 2022-12-16 10:05:03 

> 📌 ES6添加了辅助函数Object.setPrototypeOf(..)，可以用标准并且可靠的方法来修改关联。 ^22806945-70-3548-3602
   - ⌚ 2022-12-16 10:06:26 

> 📌 两种把Bar.prototype关联到Foo.prototype的方法 ^22806945-70-3638-3673
   - ⌚ 2022-12-16 10:06:33 

> 📌 掉Object.create(..)方法带来的轻微性能损失（抛弃的对象需要进行垃圾回收），它实际上比ES6及其之后的方法更短而且可读性更高。不过无论如何，这是两种完全不同的语法 ^22806945-70-3921-4009
   - ⌚ 2022-12-16 10:07:48 

> 📌 instanceof操作符的左操作数是一个普通的对象，右操作数是一个函数。instanceof回答的问题是：在a的整条[[Prototype]]链中是否有指向Foo.prototype的对象？ ^22806945-70-4614-4710
   - ⌚ 2022-12-18 11:22:12 
# 读书笔记

## 1.2 理解作用域

### 划线评论
- 📌 是否已经有一个该名称的变量存在于同一个作用域的集合中  ^415702147-7CRcxbyzi
   >  💬 所以作用域是不是相当于一个仓库？
堆栈内存？
    - ⌚ 2022-10-08 18:13:10
   
# 本书评论
