
### **JavaScript 知识体系**
#### **1. 编译时（静态语法）**
- **词法结构**
  - 标识符命名规则（变量、函数名）
  - 保留字与关键字限制
  - 分号自动插入（ASI）规则
- **语法解析**
  - AST（抽象语法树）生成
  - 语法错误检测（如括号不匹配、非法表达式）
- **作用域分析**
  - 词法作用域的静态嵌套结构
  - 变量声明提升（`var`、`function`）
  - `let`/`const` 的暂时性死区（TDZ）标记
  - 闭包作用域的预定义（函数定义时捕获外部变量）
- **模块化**
  - ES6 模块的静态依赖分析（`import`/`export`）
  - 模块作用域的隔离性（避免全局污染）
- **类与继承**
  - `class` 语法糖的静态解析（继承链、`super` 关键字）
  - 类字段和方法的声明提升与初始化顺序
- **函数定义**
  - 函数声明与函数表达式的区别
  - 箭头函数的词法 `this` 绑定（编译时确定）
  - 默认参数、剩余参数的语法解析

---

#### **2. 运行时（动态机制）**
- **执行模型**
  - **执行上下文（Execution Context）**
    - 全局上下文、函数上下文、模块上下文
    - 变量环境（Variable Environment）与词法环境（Lexical Environment）
  - **作用域链（Scope Chain）**
    - 运行时作用域链的生成与查找机制
    - 闭包的实际内存引用（外层变量保留）
  - **`this` 绑定**
    - 普通函数的动态 `this`（由调用方式决定）
    - `call`/`apply`/`bind` 显式绑定
    - 严格模式下 `this` 的默认值（`undefined`）
  - **调用栈（Call Stack）**
    - 同步代码的执行顺序
    - 栈溢出与递归限制
- **事件循环（Event Loop）**
  - **任务队列**
    - 宏任务（`setTimeout`、DOM 事件、I/O）
    - 微任务（`Promise.then`、`queueMicrotask`、`MutationObserver`）
  - **执行阶段**
    - 同步代码 → 微任务队列清空 → 宏任务队列取一个 → 重复
  - **异步操作**
    - `async/await` 的底层实现（Generator + Promise）
    - Web APIs 与事件循环的交互（如 `fetch`、`setTimeout`）
- **内存管理**
  - **垃圾回收（GC）**
    - 标记-清除算法（Mark-and-Sweep）
    - 引用计数与循环引用的缺陷
  - **内存泄漏**
    - 意外全局变量
    - 未清理的定时器、事件监听器、闭包引用
- **原型与继承**
  - **原型链（Prototype Chain）**
    - `__proto__` 与 `prototype` 的区别
    - 属性的动态查找机制（运行时沿原型链搜索）
  - **`class` 的运行时实现**
    - `extends` 的底层等价代码（基于 `Object.create` 和 `Object.setPrototypeOf`）
    - 实例方法与静态方法的存储位置
- **动态特性**
  - `eval` 和 `with` 对作用域链的运行时修改（严格模式禁用）
  - 动态属性访问（`obj[key]`）、`Proxy` 的运行时拦截
  - 动态模块加载（`import()` 的异步运行时行为）

---

### **交叉领域（编译时与运行时协作）**
- **模块加载**
  - 编译时静态分析依赖 → 运行时异步加载代码
- **JIT（即时编译）**
  - V8 引擎的隐藏类（Hidden Class）优化（运行时动态生成）
  - 函数热点代码的编译优化（如内联缓存）
- **严格模式（`use strict`）**
  - 编译时启用严格模式的语法限制（如禁止重复参数）
  - 运行时行为变更（如 `this` 默认值为 `undefined`）

---

### **总结**
- **编译时**：处理代码的静态结构（语法、作用域、声明提升），生成可执行的字节码或中间表示。
- **运行时**：动态执行代码，管理内存、事件循环、`this` 绑定等，处理不可预测的行为（如用户交互、网络请求）。
- **核心差异**：编译时关注“代码如何组织”，运行时关注“代码如何执行”。理解二者分工，是掌握 JavaScript 底层原理的关键。