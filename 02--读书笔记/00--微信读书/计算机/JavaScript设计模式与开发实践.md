---
doc_type: weread-highlights-reviews
bookId: "27337473"
author: 曾探
cover: https://weread-1258476243.file.myqcloud.com/weread/cover/90/YueWen_27337473/t7_YueWen_27337473.jpg
reviewCount: 0
noteCount: 28
isbn: 9787115388889
category: 计算机-编程设计
lastReadDate: 2023-06-19
---
# 元数据
> [!abstract] JavaScript设计模式与开发实践
> - ![ JavaScript设计模式与开发实践|200](https://weread-1258476243.file.myqcloud.com/weread/cover/90/YueWen_27337473/t7_YueWen_27337473.jpg)
> - 书名： JavaScript设计模式与开发实践
> - 作者： 曾探
> - 简介： 本书是根据JavaScript语言的特性专门针对JavaScript语言全面总结的设计模式。全书共分为三个部分，第一部分讲解了JavaScript语言面向对象和函数式编程的知识及其在设计模式方面的作用；第二部分通过一步步完善的代码示例，由浅入深地讲解了16个设计模式；第三部分讲述了面向对象的设计原则及其在设计模式中的体现，以及一些常见的面向对象编程技巧和日常开发中的代码重构。    书中所有示例均来自作者长期的开发实践，与实际开发密切相关，适合Web前端开发人员阅读。
> - 出版时间 2015-05-12 00:00:00
> - ISBN： 9787115388889
> - 分类： 计算机-编程设计
> - 出版社： 人民邮电出版社

# 高亮划线

## 1.1 动态类型语言和鸭子类型


> 📌 静态类型语言在编译时便已确定变量的类型，而动态类型语言的变量类型要到程序运行的时候，待变量被赋予某个值之后，才会具有某种类型。 ^27337473-9-563-626
   - ⌚ 2023-05-23 16:08:23 
## 1.2 多态


> 📌 多态背后的思想是将“做什么”和“谁去做以及怎样去做”分离开来，也就是将“不变的事物”与“可能改变的事物”分离开来。 ^27337473-10-1761-1818
   - ⌚ 2023-06-08 11:12:16 

> 📌 把不变的部分隔离 ^27337473-10-2071-2079
   - ⌚ 2023-06-08 11:17:16 

> 📌 当给一个类变量赋值时，这个变量的类型既可以使用这个类本身，也可以使用这个类的超类。 ^27337473-10-5127-5168
   - ⌚ 2023-06-08 11:36:16 

> 📌 从前面的讲解我们得知，多态的思想实际上是把“做什么”和“谁去做”分离开来，要实现这一点，归根结底先要消除类型之间的耦合关系。 ^27337473-10-7196-7258
   - ⌚ 2023-06-08 11:40:48 

> 📌 一个JavaScript对象，既可以表示Duck类型的对象，又可以表示Chicken类型的对象，这意味着JavaScript对象的多态性是与生俱来的。 ^27337473-10-7400-7475
   - ⌚ 2023-06-08 11:43:07 

> 📌 由此可见，某一种动物能否发出叫声，只取决于它有没有makeSound方法，而不取决于它是否是某种类型的对象，这里不存在任何程度上的“类型耦合”。 ^27337473-10-7675-7747
   - ⌚ 2023-06-08 11:45:16 

> 📌 多态最根本的作用就是通过把过程化的条件分支语句转化为对象的多态性，从而消除这些条件分支语句。 ^27337473-10-8223-8269
   - ⌚ 2023-06-08 11:48:19 
## 1.3 封装


> 📌 封装的目的是将信息隐藏。一般而言，我们讨论的封装是封装数据和封装实现。这一节将讨论更广义的封装，不仅包括封装数据和封装实现，还包括封装类型和封装变化。 ^27337473-11-419-494
   - ⌚ 2023-06-13 14:35:26 
## 1.4 原型模式和基于原型继承的JavaScript对象系统


> 📌 原型模式选择了另外一种方式，我们不再关心对象的具体类型，而是找到一个对象，然后通过克隆来创建一个一模一样的对象。 ^27337473-12-1144-1200
   - ⌚ 2023-06-19 09:34:29 

> 📌 前面说过，原型模式不仅仅是一种设计模式，也是一种编程范型。JavaScript就是使用原型模式来搭建整个面向对象系统的。 ^27337473-12-3278-3338
   - ⌚ 2023-06-19 09:47:00 
## 2.1 this


> 📌 跟别的语言大相径庭的是，JavaScript的this总是指向一个对象，而具体指向哪个对象是在运行时基于函数的执行环境动态绑定的，而非函数被声明时的环境。 ^27337473-14-421-498
   - ⌚ 2023-06-19 11:37:18 
## 3.1 闭包


> 📌 变量的作用域，就是指变量的有效范围。我们最常谈到的是在函数中声明的变量作用域。 ^27337473-17-642-681
   - ⌚ 2023-05-09 15:48:29 

> 📌 在JavaScript中，函数可以用来创造函数作用域。此时的函数像一层半透明的玻璃，在函数里面可以看到外面的变量，而在函数外面则无法看到函数里面的变量。 ^27337473-17-1118-1194
   - ⌚ 2023-05-09 15:50:14 

> 📌 变量的搜索是从内到外而非从外到内的。 ^27337473-17-1274-1292
   - ⌚ 2023-05-09 15:51:08 

> 📌 除了变量的作用域之外，另外一个跟闭包有关的概念是变量的生存周期。 ^27337473-17-1847-1879
   - ⌚ 2023-05-09 15:53:06 

> 📌 对于全局变量来说，全局变量的生存周期当然是永久的，除非我们主动销毁这个全局变量。 ^27337473-17-1908-1948
   - ⌚ 2023-05-09 15:53:41 

> 📌 而对于在函数内用var关键字声明的局部变量来说，当退出函数时，这些局部变量即失去了它们的价值，它们都会随着函数调用的结束而被销毁： ^27337473-17-1977-2042
   - ⌚ 2023-05-09 15:53:53 

> 📌 在这里产生了一个闭包结构，局部变量的生命看起来被延续了。 ^27337473-17-2730-2758
   - ⌚ 2023-05-09 15:55:05 

> 📌 这是因为div节点的onclick事件是被异步触发的，当事件被触发的时候，for循环早已结束，此时变量i的值已经是5，所以在div的onclick事件函数中顺着作用域链从内到外查找变量i时，查找到的值总是5。 ^27337473-17-3603-3707
   - ⌚ 2023-05-09 15:55:41 

> 📌 。当在事件函数中顺着作用域链中从内到外查找变量i时，会先找到被封闭在闭包环境中的i，如果有5个div，这里的i就分别是0,1,2,3,4： ^27337473-17-3762-3831
   - ⌚ 2023-05-09 15:56:04 

> 📌 1．封装变量闭包可以帮助把一些不需要暴露在全局的变量封装成“私有变量”。假设有一个计算乘积的简单函数： ^27337473-17-4777-4857
   - ⌚ 2023-05-09 15:59:31 

> 📌 提炼函数是代码重构中的一种常见技巧。如果在一个大函数中有一些代码块能够独立出来，我们常常把这些代码块封装在独立的小函数里面。独立出来的小函数有助于代码复用，如果这些小函数有一个良好的命名，它们本身也起到了注释的作用。如果这些小函数不需要在程序的其他地方使用，最好是把它们用闭包封闭起来。 ^27337473-17-6408-6551
   - ⌚ 2023-05-09 16:04:07 

> 📌 命令模式的意图是把请求封装为对象，从而分离请求的发起者和请求的接收者（执行者）之间的耦合关系。在命令被执行之前，可以预先往命令对象中植入命令的接收者。 ^27337473-17-10916-10991
   - ⌚ 2023-05-09 16:15:01 

> 📌 局部变量本来应该在函数退出的时候被解除引用，但如果局部变量被封闭在闭包形成的环境中，那么这个局部变量就能一直生存下去。从这个意义上看，闭包的确会使一些数据无法被及时销毁。使用闭包的一部分原因是我们选择主动把一些变量封闭在闭包中，因为可能在以后还需要使用这些变量，把这些变量放在闭包中和放在全局作用域，对内存方面的影响是一致的，这里并不能说成是内存泄露。如果在将来需要回收这些变量，我们可以手动把这些变量设为null。 ^27337473-17-12377-12585
   - ⌚ 2023-05-09 16:26:00 

> 📌 在IE浏览器中，由于BOM和DOM中的对象是使用C++以COM对象的方式实现的，而COM对象的垃圾收集机制采用的是引用计数策略。在基于引用计数策略的垃圾回收机制中，如果两个对象之间形成了循环引用，那么这两个对象都无法被回收，但循环引用造成的内存泄露在本质上也不是闭包造成的。 ^27337473-17-12712-12849
   - ⌚ 2023-05-09 16:27:09 
## 3.2 高阶函数


> 📌 高阶函数是指至少满足下列条件之一的函数。❏ 函数可以作为参数被传递；❏ 函数可以作为返回值输出。 ^27337473-18-421-529
   - ⌚ 2023-05-09 16:27:24 

> 📌 把函数当作参数传递，这代表我们可以抽离出一部分容易变化的业务逻辑，把这部分业务逻辑放在函数参数中，这样一来可以分离业务代码中变化与不变的部分。其中一个重要应用场景就是常见的回调函数。 ^27337473-18-763-854
   - ⌚ 2023-05-09 16:29:44 
# 读书笔记

# 本书评论
