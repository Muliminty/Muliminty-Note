以下是围绕 **数据类型** 的知识体系梳理，结合变量声明、作用域、内存管理等核心概念，从基础到深度递进：

---

### **一、基础认知（数据类型分类）**
#### 1. 基本类型（栈存储）
```javascript
let str = "hello";      // String
let num = 123;         // Number
let bool = true;       // Boolean
let nul = null;        // Null（特殊空值）
let undef = undefined; // Undefined
let sym = Symbol();    // Symbol（ES6+）
let big = 10n;         // BigInt（ES2020+）
```

#### 2. 引用类型（堆存储）
```javascript
let obj = { name: "小明" };  // Object
let arr = [1, 2, 3];        // Array
let func = () => {};        // Function
let date = new Date();      // Date
// 其他：Map、Set、WeakMap、Promise等
```

#### 3. 类型检测方法
```javascript
typeof "abc"        // "string"（无法区分null与对象）
typeof null         // "object"（历史遗留问题）
instanceof Array    // 检测构造函数（受原型链影响）
Object.prototype.toString.call([]) // "[object Array]"（最准确）
```

---

### **二、进阶特性（类型与内存）**
#### 1. 赋值与复制的差异
```javascript
// 基本类型：值拷贝
let a = 1;
let b = a;  // 内存中创建新值
b = 2;      // a仍为1

// 引用类型：地址拷贝
let obj1 = { x: 1 };
let obj2 = obj1;    // 共享同一内存地址
obj2.x = 2;         // obj1.x也变为2
```

#### 2. 函数参数传递
```javascript
function change(arg) {
  arg = 2;          // 不影响外部基本类型
}
let val = 1;
change(val);        // val仍为1

function modify(obj) {
  obj.x = 2;        // 修改堆内存数据
}
modify({ x: 1 });   // 外部对象被修改
```

#### 3. 包装对象（临时对象）
```javascript
let str = "abc";
str.length = 1;     // 临时创建String对象，操作后立即销毁
console.log(str.length); // 3（原始值未改变）
```

---

### **三、深度关联（数据类型与其他核心概念）**
#### 1. 闭包与内存泄漏
```javascript
function createClosure() {
  const bigData = new Array(1e6).fill("*"); // 大对象被闭包引用
  return () => console.log(bigData.length); 
}
// 闭包不释放时，bigData无法被GC回收 → 内存泄漏
```

#### 2. 模块化中的不可变数据
```javascript
// 模块导出常量（结合const使用）
export const API_CONFIG = Object.freeze({
  url: "https://api.example.com",
  timeout: 5000
});
// 冻结对象防止被意外修改
```

#### 3. 循环优化与弱引用
```javascript
// 使用WeakMap避免内存泄漏（键为弱引用）
const weakCache = new WeakMap();
function cacheData(obj, data) {
  weakCache.set(obj, data); // 当obj被GC时，data自动释放
}
```

---

### **四、类型转换与陷阱**
#### 1. 隐式类型转换规则
```javascript
1 + "2" = "12"       // 数字转字符串
"3" * 4 = 12         // 字符串转数字
!!"" = false         // 布尔转换
null == undefined    // true（特殊规则）
[] == ![]            // true（[]转0，![]转false→0）
```

#### 2. 严格比较与类型安全
```javascript
0 === +0             // true
NaN === NaN          // false（需用Number.isNaN()）
Object.is(NaN, NaN)  // true（ES6+）
```

#### 3. 深拷贝解决方案
```javascript
// 基础版深拷贝（不考虑循环引用）
function deepClone(obj) {
  return JSON.parse(JSON.stringify(obj));
}
// 完整方案：递归 + 处理各种类型（Date、RegExp等）
```

---

### **五、现代类型系统（TypeScript扩展）**
#### 1. 静态类型注解
```typescript
let count: number = 1;  // 显式类型声明
interface User {
  id: string;
  age?: number;        // 可选属性
}
```

#### 2. 类型守卫与收窄
```typescript
function isString(val: any): val is string {
  return typeof val === "string";
}
if (isString(input)) {
  input.toUpperCase(); // 类型自动收窄为string
}
```

#### 3. 泛型与模块化
```typescript
// 泛型函数（模块化导出）
export function identity<T>(arg: T): T {
  return arg;
}
// 使用时的类型推断
identity<string>("hello"); 
```

---

### **六、内存管理与GC优化**
#### 1. 内存生命周期
1. 分配：声明变量、函数调用时自动分配  
2. 使用：读写操作  
3. 释放：GC自动回收（引用计数、标记清除）

#### 2. 内存泄漏场景
```javascript
// 意外全局变量
function leak() {
  globalVar = new Array(1e6); // 未用var/let/const声明
}

// 未清理的定时器
const timer = setInterval(() => {}, 1000);
// 忘记clearInterval(timer)
```

#### 3. 手动内存管理技巧
```javascript
// 主动解除引用
let data = loadHugeData();
processData(data);
data = null; // 标记为可回收

// 使用WeakRef（ES2021+）
const weakRef = new WeakRef(largeObj);
// 通过weakRef.deref()安全访问
```

---

### **总结：数据类型的核心关联**
1. **变量声明**：`const` 适合基本类型常量，`let` 适合需要变化的引用类型  
2. **作用域链**：基本类型在栈中快速访问，引用类型通过作用域链查找堆地址  
3. **闭包陷阱**：捕获的引用类型变量可能导致内存无法释放  
4. **模块化设计**：使用不可变数据（Object.freeze）和类型检查保证接口安全  
5. **GC优化**：及时解除不再使用的引用，优先使用弱引用数据结构  

```javascript
// 综合示例：模块化 + 类型安全 + 内存优化
export const createCache = () => {
  const cache = new WeakMap(); // 弱引用缓存
  
  return {
    set(keyObj, value) {
      cache.set(keyObj, value);
    },
    get(keyObj) {
      return cache.get(keyObj);
    }
  };
};
```